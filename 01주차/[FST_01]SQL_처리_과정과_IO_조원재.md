# 1.1 SQL 파싱과 최적화

### 1.1.1 구조적, 집합적, 선언적 질의 언어

현재로부터 멀지 않은 과거, 단순한 로직조차 어렵게 프로그래밍 했어야 했던 시절을 지나 지금은 **옵티마이저**가 프로그래밍을 대신해 준다.

> 옵티마이저 : 사용자가 원하는 작업을 가장 효율적으로 수행할 수 있는 최적의 데이터 액세스 경로를 선택해 주는 DBMS의 핵심 엔진

### 1.1.2 SQL 최적화

#### SQL 최적화 과정

1. SQL 파싱  
   사용자로부터 SQL을 전달받으면 가장 먼저 **파서**가 **파싱**을 진행한다 - 파싱 트리 생성 - Syntax 체크 - Semantic 체크
2. SQL 최적화  
   **옵티마이저**가 담당. - 옵티마이저는 미리 수집한 시스템 및 오브젝트 **통계정보**를 바탕으로 다양한 실행경로를 생성해서 비교 후 가장 효율적인 하나를 선택한다.
3. 로우 소스 생성  
   **로우 소스 생성기**가 담당. - 옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드 또는 프로시저 형태로 포맷팅하는 단계

### 1.1.3 SQL 옵티마이저

다양한 실행경로를 확인 후 가장 저비용의 경로를 선택한다. 오랜기간 패치와 튜닝으로 자동으로 성능이 뛰어나지만 복잡한 쿼리의 경우 간혹 최적의 비용을 찾지 못하는 경우가 더러있다.

### 1.1.4 실행계획과 비용

실행계획은 보는 것은 옵티마이저가 선택한 최적의 비용 경로를 확인하는 것이다.

```SQL
explain select * from dual;
```

위와 같이 `explain`을 실행할 쿼리 앞에 작성하면 실행계획을 볼 수 있다.(MySQL 기준)

### 1.1.5 옵티마이저 힌트

1.1.3에서 말한 것과 같이 보편적으로 옵티마이저는 좋은 선택을 하지만 복잡한 쿼리일 수록 실수할 확률이 높아진다.  
이럴 땐 개발자가 직접 더 효율적인 액세스 경로를 찾아낼 수도 있는데, 이럴 때 사용하는 것이 힌트라는 기능이다. 이 기능을 사용하여 옵티마이저의 경로를 **부분**또는 **전부** 강제할 수 있다.

#### 힌트 사용방법

1. 주석 기호에 '+'를 붙인다. (권장)

```SQL
select /*+ INDEX(A 고객_PK) */
    고객명, 연락처, 주소
from 고객 A
where 고객ID = '0008'
```

2. 라인주석에 '+'를 붙인다. (비권장) -> 줄바꿈 오류등의 문제가 발생할 수 있음

```SQL
select --+ INDEX(A 고객_PK)
    고객명, 연락처, 주소
from 고객 A
where 고객ID = '0008'
```

\* 주의사항

1. 힌트 안에 인자를 나열할 땐 ','를 사용할 수 있지만, 힌트와 힌트 사이에 사용하면 안 된다.  
   `/*+ INDEX(A A_X01) INDEX(B, B_X03) */` -> 유효  
   `/*+ INDEX(C), FULL(D) */` -> 첫 번째 힌트만 유효
2. 테이블을 지정할 땐 스키마명까지 명시하면 안 된다.

```SQL
select /*+ FULL(SCOTT.EMP) */ -> 무효
from EMP
```

3. FROM 절에 ALIAS를 지정했다면, 힌트에도 반드시 별칭을 사용해야 한다.

```SQL
select /*+ FULL(EMP) */ -> 무효
from EMP E
```

```SQL
select /*+ FULL(E.EMP) */ -> 유효
from EMP E
```

\* 힌트 종류는 알아서...

# 1.2 SQL 공유 및 재사용

### 1.2.1 소프트 파싱 VS 하드 파싱

소프트, 하드 파싱을 말하기 앞서 SQL 파싱, 최적화, 로우 소스 생성 과정을 거쳐 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱하는 공간을 **라이브러리 캐시**라고 한다.  
**라이브러리 캐시**에서 찾아 곧바로 실행단계로 넘어가는 것을 **소프트 파싱**이라고 하고, 찾는 데 실패해 최적화, 로우 소스 생성 단계까지 모두 거치는 것을 **하드 파싱**이라고 한다.

#### SQL 최적화 과정은 왜 하드(Hard)한가

내비게이션이 경로를 탐색하는데 꽤나 어렵고 무거운 작업을 하는 것과 마찬가지로 옵티마이저가 SQL을 최적화할 때도 개발자들이 생각하는 것보다 훨씬 많은 일을 수행한다. 예를 들어, n개의 테이블을 조인하는 쿼리문을 최적화하는 데도 조인 순서만 n!가지를 고려해야한다. 여기에 다양한 조인 방법과 FULL SCAN, INDEX 사용 등 수십만 가지의 경우의 수가 존재한다. 그렇기 때문에 최적화 과정이 어렵다.

##### > 이 과정에서 옵티마이저가 사용하는 정보는 다음과 같다.

1. 테이블, 컬럼, 인덱스 구조에 관한 기본 정보
2. 오브젝트 통계 : (테이블, 인덱스, 컬럼) 통계
3. 시스템 통계 : CPU 속도, Single Block I/O 속도, Multiblock I/O 속도 등
4. 옵티마이저 관련 파라미터

-> 매 실행시 이와 같은 일을 진행한다면 엄청난 컴퓨팅 자원이 소모될 것이다. (라이브러리 캐시가 필요한 이유)

### 1.2.2 바인드 변수의 중요성

#### 이름없는 SQL 문제

사용자 정의 함수/프로시저, 트리거, 패키지 등은 생성할 때부터 이름을 갖는다. 컴파일한 상태로 딕셔너리에 저장되며, 사용자가 삭제하지 않는 한 영구적으로 보관된다.  
반면, SQL은 이름이 따로 없다. 때문에 딕셔너리에 저장하지도 않는다.

SQL은 텍스트 자체가 이름으로 사용되고 있기 때문에 텍스트 중에 작은 부분이라도 수정되면 그 순간 다른 객체가 새로 탄생하는 구조이기 때문에 SQL은 이름을 지정하지 않는다. (자원 낭비)

#### 공유 가능 SQL

같은 의미로 라이브러리 캐시에 저장되는 SQL의 경우 이름이 없기 때문에 같은 결과를 내는 쿼리여도 '화이트스페이스', '대소문자'등에 따라 별도의 캐시 공간을 사용한다.

```SQL
select * FROM emp WHERE empno = 79000;
SELECT * from EMP where EMPNO = 79000;

SELECT * FROM EMP WHERE EMPNO = 790;
SELECT * FROM EMP WHERE EMPNO = 780;
```

만일 파라미터 변경으로 비슷한 쿼리가 다른 공간의 캐시를 사용한다면 같은 데이터를 파라미터로 받는 프로시저를 생성하여 재사용하는 것이 효과적이다.

# 1.3 데이터 저장 구조 및 I/O 메커니즘

### 1.3.1 SQL이 느린 이유

SQL의 속도에 가장 큰 영향을 주는 요소는 디스크 I/O이다. 디스크 I/O는 상대적으로 CPU, 메모리 등에 비해 매우 느리기 때문에 해당 요소에서 병목이 일어난다.  
이를 해결하기 위해선 캐시 메모리 증설, 더 빠른 속도의 스토리지 등의 개선 방법들이 있으며 이를 개선하는 것이 SQL의 성능을 좌우한다고 해도 될 것이다.

### 1.3.2 데이터베이스 저장 구조

- 테이블스페이스 > 세그먼트 > 데이터파일

  - 테이블스페이스 : 세그먼트를 담는 콘테이너
  - 세그먼트 : 테이블, 인덱스처럼 데이터 저장공간이 필요한 오브젝트
  - 익스텐트 : 공간을 확장하는 단위. 테이블이나 인덱스에 데이터를 입력하다가 공간이 부족할 경우 테이블스페이스로부터 익스텐트를 추가로 할당받는다. 익스텐트는 연속된 블록집단.
  - 블록 : 사용자가 입력한 데이터가 실제로 저장되는 공간

  --> 익스텐트 내 블록은 서로 인접한 연속된 공간이지만, 익스텐트끼리는 연속된 공간이 아니다.

  > DBA : 데이터의 주소를 일컷는 단어  
  > ROWID : 인덱스 사용시 사용되는 값
## to be continued..
