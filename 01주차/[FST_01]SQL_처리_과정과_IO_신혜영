# 1.1 SQL파싱과 최적화

### 1.1.1 구조적, 집합적, 선언적 질의 언어

- SQL
    - Structured Query Language = 구조적 질의 언어

### 1.1.2 SQL최적화

- SQL 실행하기 전 최적화 과정
    1. SQL 파싱
        - 파싱 트리생성
        - Syntax 생성
        - Semantic 체크
    2. SQL 최적화
        - SQL 옵티마이저는 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 다양한 실행 경로를 생성하여 계획을 선택
    3. 로우소스 생성

### 1.1.3 SQL 옵티마이저

- 옵티마이저의 최적화 단계
    1. 사용자로부터 전달받은 쿼리를 수행하는 데 후보군이 될만한 실행계획들을 찾아냄
    2. 데이터 딕셔너리에 미리 수집해둔 오브젝트 통계 및 시스템 통계정보를 이용해 각 실행계획의 예상비용 선정
    3. 최저 비용을 나타내는 실행계획을 선택

# 1.2 SQL 공유 및 재사용성

### 1.2.1 소프트 파싱 vs 하드 파싱

라이브러리 캐시

- SQL파싱, 최적화, 로우 소스 생성 과정을 거쳐 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱해두는 메모리공간

소프트파싱

- 라이브러리 캐시에서 찾으면 곧바로 실행단계로 넘어가는 것

하드 파싱

- 라이브러리 캐시에서 찾지못하여 최적화 및 로우소스 생성 단계까지 모두 거치는 것

### 1.2.2 바인드 변수의 중요성

값은 따로 쿼리는 그대로라서 빠르고 안전하게 같은 쿼리를 반복실행하게 해주는 핵심기법

리터럴 ) 값이 쿼리에 박힘 → 값이 바뀌면 다른 SQL로 취급되어 매번 하드 파싱하게 됨

```sql
stmt = PREPARE "SELECT * FROM users WHERE id = ?"
-- 첫 실행: 하드 파스 → 플랜 캐시에 저장
EXECUTE stmt (1)
EXECUTE stmt (2)
EXECUTE stmt (3)
-- 이후 실행: 소프트 파스(플랜 재사용)
```

# 1.3 데이터 저장 구조 및 I/O 메커니즘

### 1.3.1 SQL이 느린 이유

SQL이 느린 이유 ⇒  디스크 I/O 때문

### 1.3.2 데이터베이스 저장구조

- 데이터베이스(레이어)
1. 논리 계층: 스키마 → 테이블/인덱스/뷰 → 파티션
2. 물리 계층: 데이터 파일(테이블 스페이스) → 세그먼트 → 익스텐트 → 페이지/블록 → 레코드(행)
3. 실행/보장 계층: 버퍼 캐시(메모리), WAL/Redo 로그, Undo/롤백, 체크포인트, MVCC

- 물리 저장 단위
    - 데이터파일: DB가 디스크에 여는 실 파일들, 묶음 단위를 DB에 따라 테이블스페이스라고 부름
    - 세그먼트(Segment): 테이블 하나, 인덱스 하나처럼 “객체 단위” 저장 묶음
    - 익스텐트(Extent): 몇 개의 페이지를 한 덩어리로 확장하는 단위
    - 페이지/블록(Page/Block): I/O의 기본단위 / 데이터를 읽고 쓰는 단위
    - 레코드(행, Row): 실제 데이터

### 1.3.3 블록단위 I/O

테이블,인덱스도 블록 단위로 읽고 쓴다

⇒ DB는 디스크 I/O를 행(row)하나 하나가 아닌, 고정 크기 덩어리로 묶어서 처리

### 1.3.4 시퀀셜 액세스 vs 랜덤 엑세스

테이블 또는 인덱스 블록을 액세스(= 읽는) 방식

- 시퀀셜엑세스
    - 논리적 또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식
- 랜덤 엑세스
    - 논리적, 물리적인 순서를 따르지 않고, 레코드 하나를 읽기 위해 한 블록씩 접근하는 방식

### 1.3.5 논리적 I/O vs 물리적 I/O

속도와 병목을 가리는 핵심개념

- 논리적 I/O
    - SQL을 처리하는 과정에 발생한 총 블록 I/O를 말한다.
- 물리적 I/O
    - DB버퍼캐시에서 블록을 찾지 못해 디스크에서 읽은 블록 I/O

→ 논리적 I/O를 줄임으로써 물리적 I/O를 줄이는 것이 곧 SQL 튜닝

인덱스만 쓰면 무조건 빠르다 → 아님 

Why? 선택도가 낮으면 인덱스 랜덤읽기가 폭증 → 테이블 풀스캔(순차I/O)가 더 빠를 수 있다.

### 1.3.6 Single Block I/O vs Multublock I/O

- Single Block
    - 한번에 한 블록씩 요청해서 메모리에 적재하는 방식
    - 인덱스 이용방식
- Multiblock I/O
    - 한번에 여러 블록씩 요청해서 메모리에 적재하는 방식

### 1.3.7 Table Full Scan vs Index Range Scan

- Table Full Scan
    - 시퀀셜 액세스와 Multiblock I/O 방식으로 디스크 블록을 읽음
- Index Range Scan
    - 랜덤액세스와 Single Block I/O방식으로 디스크 블록을 읽음

즉, 캐시에서 블록을 못찾으면 “레코드 하나를 읽기 위해 매번 자는 I/O메커니즘”이다

⇒ 인덱스가 항상 옳은 것은 아니며, Table Full Scan이 항상 나쁜것도아니다. 

참고) 실무에서 판단할 수 있는 방법 (GPT 답변)

- 실행계획 + 실행 후 통계로 **실제 반환 건수/블록 접근 수**를 확인
    - Oracle: `DBMS_XPLAN.DISPLAY_CURSOR('ALLSTATS LAST')`의 rows/bytes/consistent gets/physical reads
    - PostgreSQL: `EXPLAIN (ANALYZE, BUFFERS)`의 `hit/read`, `Rows Removed by Filter`
    - MySQL: `EXPLAIN ANALYZE`
- **선택도**가 높은가? (반환 비율이 아주 작나?) → where절을 통해 실제로 얼마나 줄어드느냐
- **커버링** 가능한가? (원하는 컬럼을 인덱스에 포함/INCLUDE) 
→쿼리에 필요한 **모든 컬럼**(SELECT·WHERE·JOIN·GROUP BY·ORDER BY)이 인덱스에 있으면 커버링
- **클러스터링/물리 정렬**은 어떤가? (Oracle CF, InnoDB의 PK 정렬 친화성)
→ “인덱스 순서대로 따라가며 테이블을 찾을 때, **그 행들이 물리적으로도 서로 가깝나?**”
- **정렬/그룹**을 인덱스로 흡수 가능한가?
→ 예시
    - `ORDER BY a, b`면, 인덱스 **선두부터 같은 순서/방향**으로 `(a, b)`가 있어야 함.
        - 역순(Desc)도 엔진이 지원하면 가능(단, 혼합 방향은 제약 있음).
    - `GROUP BY a, b`도 `(a, b)` 인덱스로 **Group Aggregation**을 할 수 있어 별도 정렬/해시를 줄임.
    - **Bitmap/Heap Scan**(예: PG)처럼 질의 계획에 따라 **정렬 유지 안 되는 스캔**이면 흡수 불가
- **통계 최신화** 되어 있나? (잘못된 추정이면 플랜이 틀어진다)

### 1.3.8 캐시 탐색 메커니즘

DB에서 데이터를 읽을 땐 이 블록이 이미 메모리(버퍼 캐시/버퍼 풀)에 있나부터 확인한다. 

- 버퍼캐시 탐색 과정을 거치는 경우
    - 인덱스 루트 블록을 읽을 때
    - 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
    - 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
    - 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때
    - 테이블 목록을 FullScan 할 때
- 버퍼 Lock
    - 읽고자 하는 블록을 찾았으면 캐시버처 체인 래치를 곧바로 해제해야함
