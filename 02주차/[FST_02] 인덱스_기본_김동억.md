# 2장. 인덱스 기본
## 2.1 인덱스 구조 및 탐색
### 2.1.1 미리 보는 인덱스 튜닝
- 테이블에서 데이터를 찾는 방법
    - 테이블 전체 스캔
    - 인덱스 이용
- 인덱스
    - 큰 테이블에서 소량 데이터를 검색할 때 사용
- 인덱스 튜닝
    - 인덱스 스캔 효율화 튜닝
    - 랜덤 엑세스 최소화 튜닝(테이블 엑세스 횟수 줄이기)
- **SQL 튜닝은 랜덤 I/O와의 전쟁**
    - ![](images/dukim/인덱스스켄_랜덤엑세스.png)
### 2.1.2 인덱스 구조
- 인덱스
    - 필요한 데이터만 빠르게 효율적으로 엑세스하기 위해 사용하는 오브젝트
    - B*Tree 인덱스 사용
        - ![](images/dukim/BTREE.png)
        - LMC(Leftmost Child)
            - 루트와 브랜치 블록에 있으며 키값을 갖지 않는 특별한 레코드
            - 자식 노드 중 가장 왼쪽 끝에 위치한 블록을 가리킴
            - LMC가 가리키는 주소로 찾아간 블록에는 키값을 가진 첫번째 레코드보다 작거나 같은 레코드 저장
        - 리프 블록
            - 키값 순으로 정렬
            - 테이블 레코드를 가리키는 주소값(ROWID)을 갖고 있음
- ROWID
    - ROWID = 데이터 오브젝트 번호 + 테이터 블록 주소(DBA, Data Block Address) + 로우 번호
    - 데이터 오브젝트 번호 = 세그먼트, 테이블 클러스터 번호
    - 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
    - 블록 번호 : 데이터파일 내에서 부여한 상대적 순번
    - 로우 번호 : 블록 내 순번
- 인덱스 탐색 과정
    - 수직적 탐색 : 인덱스 스캔 시작지점을 찾는 과정
    - 수평적 탐색 : 데이터를 찾는 과정

### 2.1.3 인덱스 수직적 탐색
- 인덱스 시작지점을 찾는 과정
    - 루트 블록 -> 브랜치 블록 ... 브랜치 블록 -> 리프 블록
    - 찾고자 하는 값보다 크거나 같은 값을 만나면, 바로 직전 레코드가 가리키는 하위 블록으로 이동
    - **조건을 만족하는 첫 번째 레코드**를 찾는 과정
### 2.1.4 인덱스 수평적 탐색
- 데이터를 찾는 과정
    - 인덱스 리프 블록끼리는 양방향 연결 리스트 구조로 앞뒤 블록에 대한 주소값을 갖음
- 인덱스를 수평적으로 탐색하는 이유
    - 조건절을 만족하는 데이터를 모두 찾기 위해서
    - ROWID를 얻기 위해서
### 2.1.5 결합 인덱스 구조와 탐색
- 두 개 이상 컬럼을 결합해서 인덱스를 만들 수 있음
    - ![](images/dukim/결합인덱스.png)
- 인덱스 컬럼 순서 변경하여도 '=' 조건으로 검색할 때는 성능이 같음(블록 I/O 개수 같음)

## 2.2 인덱스 기본 사용법
### 2.2.1 인덱스를 사용한다는 것
- 찾고자 하는 값으로 정렬되어 있음(값들이 서로 모여 있음)
- **인덱스를 정상적으로 사용한다**의 의미
    - 리프 블록에서 스캔 시작점을 찾아 스캔하고 중간에 멈추는 것
    - Index Range Scan 방식
- 가공한 값이나 중간값(중간에 포함된 값)으로 스캔시 
    - 시작점을 찾을 수 없음
    - 스캔하다가 중간에 멈출 수 없음
    - 찾고자 하는 값들이 흩어져 있음
    - 전체를 스캔해야 함
    - Index Full Scan 방식

### 2.2.2 인덱스를 Range Scan 할 수 없는 이유
- 인덱스 스캔 시작점을 찾을 수 없기 때문
- Index Range Scan하려면 **시작점**과 **끝지점**이 있어야 함
- Index Range Scan을 사용하는 예시
```
/* 가공 값 */
where substr(생년월일, 5, 2) = '05'
/* 중간 값 */
where 업체명 like '%대한%'
/* OR 연산 */
where (전화번호 = :tel_no OR 고객명 = :cust_nm)
```
- OR Expansion
    - 힌트를 통해 옵티마이저가 Index Range Scan을 사용하도록 변경
```
select /*+use_concat */ * from 고객
where (전화번호 = :tel_no OR 고객명 = :cust_nm)

/* 실행계획에서 아래와 같은 효과를 보임 */
select *
from 고객
where 고객명 = :cust_nm  -- 고객명이 선두 컬럼인 인덱스 Range Scan
union all
select *
from 고객
where 전화번호 = :tel_no -- 전화번호가 선두 컬럼인 인덱스 Range Scan
and (고객명 <> :cust_nm or 고객명 is null)
```

### 2.2.3 더 중요한 인덱스 사용 조건
### 2.2.4 인덱스를 이용한 소트 연산 생략
### 2.2.5 ORDER BY 절에서 컬럼 가공
### 2.2.6 SELECT-LIST에서 컬럼 가공
### 2.2.7 자동 형변환

## 2.3 인덱스 확장기능 사용법
### 2.3.1 Index Range Scan
### 2.3.2 Index Full Scan
### 2.3.3 Index Unique Scan
### 2.3.4 Index Skip Scan
### 2.3.5 Index Fast Full Scan
### 2.3.6 Index Range Scan Descending