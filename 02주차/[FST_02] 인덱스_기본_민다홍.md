# 2장. 인덱스 기본

## 2.1 인덱스 구조 및 탐색

### 인덱스 튜닝의 핵심 요소

**1. 인덱스 스캔 과정에서 발생하는 비효율을 줄이기 : 인덱스 스캔 효율화 튜닝**

---
#### [예시] : 학생명부에서 시력이 1.0 ~ 1.5인 홍길동 학생을 찾는 경우
#### 1. 이름 → 시력 순

학생 명부를 **이름 → 시력** 순으로 정렬했다면 **소량만 스캔**하면 됨.

| 이름    | 시력 | 학년-반-번호    |
|---------|------|-----------------|
| 홍길동  | 1.0  | 1학년 3반 2번  |
| 홍길동  | 1.3  | 5학년 3반 7번  |
| ...     | ...  | ...            |

#### 2. 시력 → 이름 순

**시력 → 이름** 순으로 정렬시, 똑같이 두 명을 찾는데도 **많은 양을 스캔**해야 함.

| 시력 | 이름    | 학년-반-번호    |
|------|---------|-----------------|
| 1.0  | 김철수  | 1학년 3반 2번  |
| 1.0  | 홍길동  | ...            |
| ...  | ...     | ...            |
| 1.3  | 홍길동  | 5학년 3반 7번  |
| ...  | ...     | ...            |

---


**2.테이블의 엑세스 횟수 줄이기 : 랜덤 엑세스 최소화 튜닝**

시력이 1.0 ~ 1.5인 학생: 50명

이름이 '홍길동'인 학생: 5명

만약 이름순 정렬, 시력순 정렬한 학생 명부가 따로 있다면 이름순으로 정렬한 학생명부를 사용하는 것이 더 효율적이다.

#### **랜덤액세스 효율화 > 인덱스 스캔 효율화**
---

#### 2.1.2 인덱스 구조

인덱스는 대용량 테이블에서 필요한 데이터만 빠르게 효율적으로 액세스하기 위해 사용하는 오브젝트이다.
- 주요 특징

범위 스캔(Range Scan) 가능

B*Tree 인덱스 사용

2.1.3 수직적 탐색
> ***조건을 만족하는 첫 번째 레코드***를 찾는 과정

2.1.4 수평적 탐색
>***데이터를 찾는 과정***
1. 조건절을 만족하는 데이터를 모두 찾기 위해서
2. ROWID를 얻기 위해서(일반적으로 인덱스를 스캔하고, 테이블도 엑세스함)


#### 2.1.5 결합 인덱스와 구조적 탐색



인덱스 **선두 컬럼을 모두 '=' 조건**으로 검색할 때는:

| 인덱스 구성 | 읽는 블록 개수 |
|-------------|----------------|
| [고객명 + 성별] | 동일 |
| [성별 + 고객명] | 동일 |

> 선두 컬럼이 모두 등치 조건(=)일 때는 컬럼 순서가 성능에 미치는 영향이 없다.

---

## 2.2 인덱스 기본 사용법

### 2.2.1 인덱스를 사용한다는 것

목차에서 인덱스를 포함한 목차 찾기,  테이블을 포함한 목차 찾기

-> 시작점을 찾을 수 없고, 중간에 멈출 수 없다. 찾고자 하는 단어들이 흩어져있기 때문에 **전체를 스캔**해야 한다.

>인덱스를 사용한다 : 리프블록에서 스캔 시작점을 찾아 거기서부터 스캔하다가 중간에 멈추는 **Range Scan**

---

### 2.2.2 인덱스를 Range Scan 할 수 없는 이유

**'인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다'** → 인덱스 스캔의 시작점을 찾을 수 없기 때문이다.

**Index Range Scan**에서 **Range**는 범위를 의미한다. **시작과 끝 지점이 있어야 한다**는 뜻이다.

####  시작지점과 끝지점이 명확함

```sql
WHERE 생년월일 BETWEEN '20070101' AND '20070131';
```

####  시작지점과 끝지점이 명확하지 않음

```sql
WHERE SUBSTR(생년월일,5,2) = '05';
WHERE 업체명 LIKE '%대한%';
WHERE (전화번호 = :TEL_NO OR 고객명 = :CUST_NM);
WHERE 전화번호 IN (:TEL_NO1, :TEL_NO2);
```

#### ? 해결 방법: 각 브랜치별로 인덱스 스캔 시작점 찾기

```sql
SELECT * FROM 고객 WHERE 전화번호 = :TEL_NO1
UNION ALL
SELECT * FROM 고객 WHERE 전화번호 = :TEL_NO2
```

> **IN-List Iterator 방식**: IN-List의 개수만큼 Index Range Scan을 반복하는 것  
> **참고**: OR 또는 IN 조건절은 옵티마이저의 쿼리변환 기능을 통해 Index Range Scan으로 처리되기도 함

---

### 2.2.3 더 중요한 인덱스 사용조건

**인덱스 선두컬럼이 조건절에 있어야 한다**

#### 예시: 인덱스가 [소속팀+사원명+연령] 순으로 구성된 경우

```sql
SELECT 사원번호, 소속팀, 연령, 입사일자, 전화번호
FROM 사원
WHERE 사원명 = '홍길동'
```

**인덱스를 타지 않음**

>  [소속팀+사원명+연령]은 데이터를 소속팀 기준으로 정렬하고, 소속팀이 같다면 사원명순으로, 사원명이 같다면 연령순으로 정렬. 선두컬럼인 소속팀이 조건절에 없음.

#### 예시: 선두 컬럼이 가공되지 않은 상태

```sql
-- 인덱스: [기준연도 + 과세구분코드 + 보고회차 + 실명확인번호]
SELECT * FROM TXA1234
WHERE 기준연도 = :STDR_YEAR
  AND SUBSTR(과세구분코드, 1, 4) = :TXTN_DCD
  AND 보고회차 = :RPT_TMRD
  AND 실명확인번호 = :RNM_CNFM_NO
```

**Range Scan 가능**

> 선두 컬럼이 가공되지 않은 상태로 조건절에 있음

---

### 인덱스를 잘 타니까 튜닝 끝?

```sql
-- 인덱스: [주문일자 + 상품번호]
SELECT * FROM 주문상품
WHERE 주문일자 = :ORD_DT
  AND 상품번호 LIKE '%PING%';

SELECT * FROM 주문상품
WHERE 주문일자 = :ORD_DT
  AND SUBSTR(상품번호, 1, 4) = 'PING';
```

이 쿼리에서 상품번호는 **스캔 범위를 줄이는 데 역할을 하지 못함**

>  이 쿼리들이 인덱스를 잘 탄다고 할 수 있을까?

---

### 2.2.4 인덱스를 이용한 소트 연산 생략

```sql
-- 인덱스: [장비번호 + 변경일자 + 변경순번]
SELECT * FROM 상태변경이력
WHERE 장비번호 = 'C'
  AND 변경일자 = '20180316'
ORDER BY 변경순번 DESC
```

**소트 연산 생략 가능**: 인덱스가 이미 정렬되어 있음

---

### 2.2.5 ORDER BY 절에서 컬럼 가공

```sql
-- 인덱스: [장비번호 + 변경일자 + 변경순번]

--  소트 생략 가능
SELECT * FROM 상태변경이력
WHERE 장비번호 = 'C'
ORDER BY 변경일자, 변경순번
```
> 수직적 탐색을 통해 장비번호가 'C'인 레코드를 찾아 인덱스 리프를 스캔하면 자동으로 [변경일자+변경순번]으로 정렬됨

```sql
--  소트 생략 불가
SELECT * FROM 상태변경이력
WHERE 장비번호 = 'C'
ORDER BY 변경일자 || 변경순번
```
> 인덱스에는 가공하지 않은 채로 값을 저장했는데, 가공한 값을 기준으로 정렬을 요청했기 때문이다.

#### [예시]

```sql
SELECT * FROM (
    SELECT TO_CHAR(A.주문번호, 'FM00000') AS 주문번호,
           A.업체번호, A.주문금액
    FROM 주문 A
    WHERE A.주문일자 = :dt
      AND A.주문번호 > NVL(:next_ord_no, 0)
    ORDER BY 주문번호
) WHERE ROWNUM <= 30
```

ORDER BY 주문번호는 `TO_CHAR(A.주문번호, 'FM00000')`를 가리키기 때문에 실행계획에서 **SORT ORDER BY** 연산이 나타남

---

### 2.2.6 SELECT-LIST에서 컬럼 가공

```sql
-- 
SELECT MIN(변경순번) FROM 상태변경이력
WHERE 장비번호='C' AND 변경일자='20180316';

SELECT MAX(변경순번) FROM 상태변경이력
WHERE 장비번호='C' AND 변경일자='20180316';

-- XXX
SELECT NVL(MAX(TO_NUMBER(변경순번)),0) FROM 상태변경이력
WHERE 장비번호='C' AND 변경일자='20180316';
```
> 숫자값으로 바꾼 값을 기준으로 정렬을 요구해서 불가능

```sql
-- 이렇게 변경하면 가능
SELECT NVL(TO_NUMBER(MAX(변경순번)),0) FROM 상태변경이력
WHERE 장비번호='C' AND 변경일자='20180316';
```

---

### 2.2.7 자동 형변환

```sql
SELECT * FROM 고객
WHERE 생년월일 = 19821225
```

**문제점**: 옵티마이저는 테이블 전체 스캔을 선택. 생년월일 컬럼이 문자형인데 숫자형으로 표현했기 때문이다.

####  형변환 우선순위

- **숫자형 > 문자형**
- **날짜형 > 문자형**
- **LIKE 연산자**: 문자열 비교 연산이기 때문에 문자형 기준으로 숫자형 컬럼이 변환


```sql
SELECT ROUND(AVG(SAL)) AVG_SAL,
       MIN(SAL) MIN_SAL,
       MAX(SAL) MAX_SAL,
       MAX(DECODE(JOB,'PRESIDENT',NULL,SAL)) MAX_SAL2
FROM EMP;
```

**문제점**: 오라클이 DECODE 함수를 처리할 때 내부 형변환 규칙으로 엉뚱한 값이 나옴

**DECODE(A,B,C,D)**: 'A'='B'이면 'C'를 반환하고 아니면 'D'를 반환. 반환 데이터 타입은 'C'로 결정됨.

- 'C'가 NULL(문자형)이므로 SAL을 문자열로 변환
- 문자열 기준으로 가장 큰 값인 '950'을 출력


```sql
MAX(DECODE(JOB,'PRESIDENT',TO_NUMBER(NULL),SAL)) MAX_SAL2
-- 또는
MAX(DECODE(JOB,'PRESIDENT',0,SAL)) MAX_SAL2
```


**자동형변환 기능에 의존하지 말고, 인덱스 컬럼 기준으로 반대편 컬럼 또는 값을 정확히 형변환하자.**

- 형변환 함수의 연산 횟수 증가로 인한 성능 저하 우려는 불필요
- SQL 성능은 **블록 I/O를 줄이는 것**에서 결정됨
- 형변환 함수를 생략해도 옵티마이저가 자동으로 생성함


---

### 2.3.4 Index Skip Scan

**인덱스 선두 컬럼이 조건절에 없어도** 인덱스를 활용하는 새로운 스캔방식 

**조건절에 빠진 인덱스 선두 컬럼의 Distinct Value 개수가 적고 후행 컬럼의 Distinct Value 개수가 많을 때 유용** 하다.

#### [예시]
고객 테이블에서:
- **Distinct Value가 적은 컬럼**: '성별' 
- **Distinct Value가 많은 컬럼**: 고객번호

```sql
SELECT /*+ index_ss(사원 사원_IDX) */ * 
FROM 사원 
WHERE 연봉 BETWEEN 2000 AND 4000;
```

#### 동작 원리

**루트 또는 브랜치에서 읽은 컬럼 값 정보를 이용해 조건절에 부합하는 레코드를 포함할 \
'가능성이 있는' 리프 블록만 골라서 액세스하는 스캔 방식**

1. **남 & 800 이하인 레코드**를 담고 있어서 이 블록은 액세스 하지 않아도 될 것 같지만, '남'보다 작은 성별값이 혹시 존재한다면, 액세스 해야만 한다.

2. **두 번째 레코드가 가리키는 블록**은 남&800 이상이면서, 남&1500 이하인 레코드를 담고 있다. 존재할 가능성이 없으므로 Skip한다.

3. **여섯 번째**는 남&10000 이상이므로 연봉구간을 초과하지만, 여&3000 이하인 데이터를 담고 있기 때문에 액세스한다.

4. **마지막으로 열 번째 리프블록**도 마찬가지로 '여'보다 큰 성별 값이 존재할 수 있으니 액세스 해야만 한다.

#### 작동 조건

- **Distinct Value가 적은 선두컬럼이 조건절에 없는 경우**에도 사용 가능하다.
- **인덱스 선두 컬럼이 없을 때만 작동하는 것은 아니다.**
- **선두 컬럼이 부등호, BETWEEN, LIKE 같은 범위검색 조건일 때도** Index Skip Scan을 사용할 수 있다.
- **수행횟수가 적은 SQL을 위해 인덱스를 추가하는 것이 비효율적일 때** 사용하는 것이 바람직함.

---

### 2.3.5 Index Fast Full Scan

**Index Full Scan보다 빠르게 동작**한다.
> **논리적인 인덱스 트리 구조를 무시하고 인덱스 세그먼트 전체를 Multiblock I/O 방식으로 스캔**하기 때문이다.

####

- **Multiblock I/O방식**을 사용하므로 디스크로부터 대량의 인덱스 블록을 읽어야 할 때 큰 효과를 발휘
- **속도는 빠르지만** 연결리스트 구조를 무시한 채 데이터를 읽기 때문에 **결과집합이 인덱스 키 순서대로 정렬되지 않음**
- **쿼리에 사용한 컬럼이 모두 인덱스에 포함돼 있을 때만** 사용할 수 있다.
- **인덱스가 파티션 돼 있지 않더라도 병렬쿼리가 가능**

---

### Index Full Scan vs Index Fast Full Scan

| **특징** | **Index Full Scan** | **Index Fast Full Scan** |
|----------|---------------------|---------------------------|
| **스캔 방식** | 인덱스 구조(트리)를 따라 순차적으로 스캔 | 인덱스 세그먼트 전체를 스캔 |
| **I/O 방식** | 단일 블록 I/O (Single-block I/O) | 멀티블록 I/O (Multiblock I/O) |
| **결과 순서** | 결합 집합 순서 보장 (인덱스 순서대로 반환) | 순서 보장 안 함 |
| **병렬 스캔** | 파티션되지 않은 경우 병렬 스캔 불가 | 병렬 스캔 가능 |
| **컬럼 조회** | 인덱스에 포함되지 않은 컬럼도 조회 가능 | 인덱스에 포함된 컬럼만 조회 가능 |

---

### 2.3.6 Index Range Scan Descending

**Index Range Scan과 기본적으로 동일한 스캔 방식**

 인덱스를 뒤에서부터 앞쪽으로 스캔하기 때문에 **내림차순으로 정렬된 결과집합을 얻는다는 점만 다르다.**

```sql
SELECT * 
FROM EMP 
WHERE EMPNO > 0 
ORDER BY EMPNO DESC
```

**옵티마이저가 알아서 인덱스를 거꾸로 읽는 실행계획을 실행**한다. 만약 하지 않으면 **INDEX_DESC 힌트를 사용해서 유도 가능**하다.


