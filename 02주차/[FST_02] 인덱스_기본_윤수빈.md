# 2장. 인덱스 기본
## 2.1 인덱스 구조 및 탐색
- 인덱스 탐색 과정 : 수직적 탐색, 수평적 탐색
### 2.1.1 미리보는 인덱스 튜닝
- 인덱스 : 찾기 쉽게 정렬해두는 것
- ROWID : 오라클에서 각 행을 고유하게 식별할 수 있는 물리적인 주소값 (어느 datafile 의 몇번째 블록 몇번째 행 -> 실제 디스크 상의 위치)
- 인덱스 튜닝의 두 가지 핵심요소 : 인덱스 스캔 효율화 튜닝(인덱스 스캔 과정에서 발생하는 비효율 줄이기), 랜덤 액세스 최소화 튜닝(테이블 액세스 횟수 줄이기) => 중요도 ↑

=> SQL 튜닝은 랜덤 I/O 와의 전쟁

- OLTP 시스템(온라인 트랜잭션 처리 시스템) : 일상적인 비즈니스 거래와 데이터 변경 작업을 실시간으로 처리하는 데이터베이스 시스템
- NL 조인 : 두개 이상 테이블을 한번에 한 레코드씩 순차적으로 조인하는 방식
- 소트머지 조인 : 양쪽 테이블 정렬 후 머지하는 방식
- 해시 조인: 작은 테이블로 해시 테이블을 생성 후 큰 테이블을 탐색하여 조인하는 방식
<img width="568" height="202" alt="image" src="https://github.com/user-attachments/assets/33bb611b-1494-44d9-b44e-8af40ec023f9" />

### 2.1.2 인덱스 구조
- 인덱스 정렬 => 범위 스캔 가능
- B*Tree 인덱스(B는 Balanced의 약자 => 루트로 부터 모든 리프 블록까지 높이는 동일) : 뿌리 (루트), 가지(브랜치), 잎사귀(리프)
- 루트와 브랜치 블록에 있는 각 레코드는 하위 블록에 대한 주소값을 가짐
- 키값은 하위 블록에 저장된 키값의 범위
- 키값을 갖지 x 레코드 : LMC (자식 노드 중 가장 왼쪽 끝 블록)
- 각 레코드는 ROWID(레코드를 가리키는 주소값)를 가짐
- ROWID
  1. ROWID = 데이터 블록 주소 + 로우 번호
  2. 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
  3. 블록 번호 : 데이터 파일 내에서 부여한 상대적 순번
  4. 로우 번호 : 블록 내 순번

### 2.1.3 인덱스 수직적 탐색
- 인덱스 스캔 시작지점을 찾는 과정
- 조건을 만족하는 첫 번째 레코드를 찾는 과정

### 2.1.4 인덱스 수평적 탐색
- 본격적으로 데이터를 찾는 과정

### 2.1.5 결합 인덱스 구조와 탐색
- 두 개 이상의 컬럼을 결합하여 인덱스 생성
- 인덱스 선두 컬럼을 모두 "=" 조건으로 검색 시 컬럼 순서와 상관없이 성능 동일 => 블록 I/O 개수 동일

## 2.2 인덱스 기본 사용법
- 인덱스를 Range Scan 하는 방법
### 2.2.1 인덱스를 사용한다는 것
- 인덱스를 정상적으로 사용한다 => 리프 블록 일부만 스캔사는 Index Range scan을 의미
### 2.2.2 인덱스를 Range Scan 할 수 없는 이유
- 인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다. => 인덱스 스캔 시작점을 찾을 수 없기 때문
### 2.2.3 더 중요한 인덱스 사용 조건
- 인덱스 선두 컬럼이 가공하지 않은 상태로 조건절에 있어야 함 => Range Scan 가능
- 인덱스를 탄다 = 인덱스를 Range Scan 한다
- 인덱스를 정말 잘 타는지 => 인덱스 리프 블록에서 스캔하는 양에따라
### 2.2.4 인덱스를 이용한 소트 연산 생략
### 2.2.5 ORDER BY 절에서 컬럼 가공
- 조건절이 아닌 ORDER BY 또는 SELECT-LIST에서 컬럼 가공 => 인덱스 정상적으로 사용할 수 없는 경우
### 2.2.6 SELECT-LIST에서 컬럼 가공
- 옵티마이저가 정렬 연상 따로 수행하지 않는 경우 => 최소값 구할 때 & 최대값 구할 때
- 정렬 연산 생략 불가한 경우 => 인덱스에는 변경순번이 문자열 기준으로 정렬 => MAX(TO_NUMBER(변경순번)) 와 같은 경우
  => 따라서 TO_NUMBER(MAX(변경순번))로 변경해야 함
### 2.2.7 자동 형변환
- 각 조건절에서 양쪽 값의 데이터 타입이 서로 다를 시 값 비교 불가 => 오라클의 경우 자동으로 형변환
- 기본 : 숫자형 > 문자형
- 연산자가 LIKE일 경우 : 문자형 > 숫자형
- 주의할 점
  1. LIKE, BETWEEN 조건 함께 사용 시 인덱스 스캔 효율 ↓ => 특히 숫자형 컬럼을 LIKE 에 사용 시
  2. 숫자로 변환할 수 없는 문자열 입력 시 에러발생
  3. 기능에 의존 X 인덱스 컬럼 기준으로 반대편 컬럼 또는 값을 명확히 형변환해 주어야 함

## 2.3 인덱스 확장기능 사용법
### 2.3.1 Index Range Scan
- 인덱스 루트에서 리프 블록까지 수직적 탐색 후 필요한 범위만 스캔
<img width="412" height="197" alt="image" src="https://github.com/user-attachments/assets/a8595d91-54b0-4b64-b7fa-ccecbded07ee" />
=> 성능은 인덱스 스캔 범위, 테이블 액세스 횟수 얼마나 줄일 수 있느냐로 결정
### 2.3.2 Index Full Scan
- 인덱스 리프블록 모두 탐색
<img width="405" height="192" alt="image" src="https://github.com/user-attachments/assets/749e1d67-e2ca-4051-9c46-c510d6c88cef" />
- 인덱스 컬럼 순으로 정렬되므로 Sort Order By 연산 생략 목적으로 사용 가능 
### 2.3.3 Index Unique Scan
- 수직적 탐색만으로 데이터 찾는 스캔 방식 => 인덱스를 "=" 조건으로 탐색하는 경우에 작동
<img width="363" height="177" alt="image" src="https://github.com/user-attachments/assets/b3759552-2f51-46c1-bc1c-5091bb33e897" />
### 2.3.4 Index Skip Scan
- 인덱스 선두 컬럼이 조건절에 없어도 인덱스를 활용하는 새로운 스캔 방식
- 인덱스 선두 컬럼의 Distinct Value 개수가 적고, 후행 컬럼 Distinct Value 개수가 많을 때 유용
<img width="361" height="176" alt="image" src="https://github.com/user-attachments/assets/5b4c04b9-90f0-44c4-8da8-8a74e8be5f0c" />
### 2.3.5 Index Fast Full Scan
- 논리적인 인덱스 트리 구조를 무시하고 인덱스 세그먼트 전체를 Multiblock I/O 방식으로 스캔
- 디스크로부터 대량의 인덱스 블록을 읽어야 할 때 효과적
### 2.3.6 Index Range Scan Descending
- Index Range Scan과 기본적으로 동일하나 차별점은 내림차순으로 정렬된 결과집합을 얻음
<img width="349" height="170" alt="image" src="https://github.com/user-attachments/assets/92f2f1e9-6e10-49b9-83e4-06b6ddf5aae2" />
- 인덱스를 거꾸로 읽지 않을 때, index_desc 힌트로 유도
