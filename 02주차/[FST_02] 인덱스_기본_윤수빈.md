# 2장. 인덱스 기본
## 2.1 인덱스 구조 및 탐색
- 인덱스 탐색 과정 : 수직적 탐색, 수평적 탐색
### 2.1.1 미리보는 인덱스 튜닝
- 인덱스 : 찾기 쉽게 정렬해두는 것
- ROWID : 오라클에서 각 행을 고유하게 식별할 수 있는 물리적인 주소값 (어느 datafile 의 몇번째 블록 몇번째 행 -> 실제 디스크 상의 위치)
- 인덱스 튜닝의 두 가지 핵심요소 : 인덱스 스캔 효율화 튜닝(인덱스 스캔 과정에서 발생하는 비효율 줄이기), 랜덤 액세스 최소화 튜닝(테이블 액세스 횟수 줄이기) => 중요도 ↑

=> SQL 튜닝은 랜덤 I/O 와의 전쟁

- OLTP 시스템(온라인 트랜잭션 처리 시스템) : 일상적인 비즈니스 거래와 데이터 변경 작업을 실시간으로 처리하는 데이터베이스 시스템
- NL 조인 : 두개 이상 테이블을 한번에 한 레코드씩 순차적으로 조인하는 방식
- 소트머지 조인 : 양쪽 테이블 정렬 후 머지하는 방식
- 해시 조인: 작은 테이블로 해시 테이블을 생성 후 큰 테이블을 탐색하여 조인하는 방식
<img width="568" height="202" alt="image" src="https://github.com/user-attachments/assets/33bb611b-1494-44d9-b44e-8af40ec023f9" />

### 2.1.2 인덱스 구조
- 인덱스 정렬 => 범위 스캔 가능
- B*Tree 인덱스(B는 Balanced의 약자 => 루트로 부터 모든 리프 블록까지 높이는 동일) : 뿌리 (루트), 가지(브랜치), 잎사귀(리프)
- 루트와 브랜치 블록에 있는 각 레코드는 하위 블록에 대한 주소값을 가짐
- 키값은 하위 블록에 저장된 키값의 범위
- 키값을 갖지 x 레코드 : LMC (자식 노드 중 가장 왼쪽 끝 블록)
- 각 레코드는 ROWID(레코드를 가리키는 주소값)를 가짐
- ROWID
  1. ROWID = 데이터 블록 주소 + 로우 번호
  2. 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
  3. 블록 번호 : 데이터 파일 내에서 부여한 상대적 순번
  4. 로우 번호 : 블록 내 순번

### 2.1.3 인덱스 수직적 탐색
- 인덱스 스캔 시작지점을 찾는 과정
- 조건을 만족하는 첫 번째 레코드를 찾는 과정

### 2.1.4 인덱스 수평적 탐색
- 본격적으로 데이터를 찾는 과정

### 2.1.5 결합 인덱스 구조와 탐색
- 두 개 이상의 컬럼을 결합하여 인덱스 생성
- 인덱스 선두 컬럼을 모두 "=" 조건으로 검색 시 컬럼 순서와 상관없이 성능 동일 => 블록 I/O 개수 동일

## 2.2 인덱스 기본 사용법
- 인덱스를 Range Scan 하는 방법
### 2.2.1 인덱스를 사용한다는 것
- 인덱스를 정상적으로 사용한다 => 리프 블록 일부만 스캔사는 Index Range scan을 의미
### 2.2.2 인덱스를 Range Scan 할 수 없는 이유
- 인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다. => 인덱스 스캔 시작점을 찾을 수 없기 때문
