# 인덱스 기본

## 인덱스 구조 및 탐색

### 2.1.1 미리 보는 인덱스 튜닝

#### 데이터를 찾는 두가지 방법

데이터를 찾는 방법은 수십 년에 걸쳐 아무리 발전해도 아래 두가지 방법에서 벗어나지 못하고 있다.

1. 데이터 전체를 스캔
2. 인덱스 사용

#### 인덱스 튜닝의 두 가지 핵심요소

인덱스는 큰 테이블에서 소량의 데이터를 검색할 때 사용하는데, 이런 시스템은 주로 **온라인 트랜잭션 처리** 시스템에서 사용하므로 튜닝이 무엇보다 중요하다.

> 온라인 트랜잭션 처리 (OLTP) : OLTP는 은행·쇼핑몰·SNS처럼 수많은 사용자가 동시에 데이터를 실시간으로 빠르고 정확하게 다루는 시스템

1. **인덱스 스캔 효율화 튜닝** : 인덱스 스캔 과정에서 발생하는 비효율을 줄이는 것
2. **랜덤 액세스 최소화 튜닝** : 테이블 액세스 횟수를 줄이는 것

- 우리가 흔히 사용하는 서비스는 랜덤 액세스 최소화 튜닝이 잘 이루어져야 한다.

#### SQL 튜닝은 랜덤 I/O와의 전쟁

데이터베이스 성능이 느린 이유는 디스크 I/O 때문으로 읽어야 할 데이터량이 많고, 그 과정에 디스크 I/O가 많이 발생할 때 느리다.

### 2.1.2 인덱스 구조

> **인덱스** : 대용량 테이블에서 필요한 데이터만 빠르게 효율적으로 액세스하기 위해 사용하는 오브젝트

- DBMS는 일반적으로 BTree 인덱스를 사용한다.  
  BTree 요약
  - 목적 : 최소한의 디스크 I/O로 빠르게 찾고 정렬된 순회를 하려는 자료구조
  - 구조 : 한 노드안에 많은 키와 포인터를 넣어 높이를 아주 낮게 유지(평균 2~4레벨)
  - 동작 : 루트 -> 내부노드 -> 리프노드로 내려가며 이진탐색처럼 분기, 리프는 정렬 + 옆 리프와 연결
  - 효과 : 대량 데이터에서도 평균 (3~4회) 안에 페이지 접근으로 조회 가능

인덱스 탐색 과정은 수직적 탐색과 수평적 탐색으로 나눌 수 있다.
<img width="1280" height="507" alt="image" src="https://github.com/user-attachments/assets/02b684c5-3524-4d7e-bb7b-92b79f346b22" />


- 수직적 탐색 : 인덱스 스캔 시작지점을 찾는 과정
- 수평적 탐색 : 데이터를 찾는 과정

### 2.1.3 인덱스 수직적 탐색

정렬된 인덱스 레코드 중 조건을 만족하는 첫 번째 레코드를 찾는 과정 -> 인덱스 스캔 시작지점을 찾는 과정

- 루트 노드부터 리프 노드까지 아래와 같이 탐색을 하는 것

1. 찾고자 하는 값(A)이 노드에 있는지 확인
2. 노드에 없을 경우 A보다 큰 값 이전이 가리키는 하위 노드로 이동
3. 2번과 같은 방식으로 탐색 후 조건을 만족하는 첫 번째 레코드를 반환

예를 들어 아래와 같은 쿼리가 있다고 할 때, 수직적 탐색은 '2025-08-01' 이상인 첫 번째 레코드 위치를 찾는 것

```SQL
select * from orders where order_date >= '2017-05-05';
```

### 2.1.4 인덱스 수평적 탐색

수직적 탐색으로 스캔 시작점을 찾았다면, 찾고자 하는 데이터가 더 안나타날 때까지 인덱스 리프 블록을 수평적으로 스캔한다. 즉, 본격적으로 데이터를 찾는 과정이다.

- 리프 노드에서 옆으로 쭉 읽어 나가며 조건을 만족하는 데이터를 가져오는 과정

```SQL
select * from orders where order_date >= '2017-05-05';
```

1. 수직적 탐색으로 '2017-05-05'의 위치를 찾았다면, 그 뒤로 '2017-05-06', '2017-05-07', ... 등 범위에 맞는 레코드를 순차적으로 스캔한다.

- 리프 노드들은 정렬된 상태로 저장되고, 옆 노드와 Linked List로 이루어져 있다.

만약 조건이 '='와 같을 경우 수평적 탐색이 필요없을 수 있다.

### 2.1.5 결합 인덱스 구조와 탐색

복합 인덱스의 경우 단일 인덱스와 마찬가지로 수직 탐색 후 수평 탐색을 진행한다.  
예를 들어 (A, B)의 인덱스가 있을 경우 A의 값을 찾은 후 B의 값을 찾는 것이 아닌 A이면서 B인 값을 찾는 것이다.

## 2.2 인덱스 기본 사용법

### 2.2.1 인덱스를 사용한다는 것

👉 Index Range Scan : 인덱스를 일정 구간(범위) 스캔하는 방식

- '=' 하나만 찾는 경우 -> Index Unique Scan (한 값만 읽음)
- BETWEEN, >=, <=, LIKE 처럼 번위 조건 -> Index Range Scan (범위 구간 읽음)  
  즉, 수직 탐색으로 조건의 시작점을 찾은 후 수평 탐색으로 조건의 종료지점까지 스캔

**사용가능한 조건**

```SQL
- col = ?
- col > ?, col >= ?, col < ?, col <= ?
- col BETWEEN ? AND ?
- col LIKE 'abc%'
- col IN ( ... )
```

### 2.2.2 인덱스를 Range Scan 할 수 없는 이유

인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다. (Range Scan 할 수 없다.)  
-> 인덱스는 원본 컬럼 값이 정렬된 상태로 저장되어 있으나 함수나 특정 연산으로 가공할 경우 정렬된 순서가 꺠져 스캔의 시작점을 찾을 수 없기 때문이다.

```SQL
-- order_date의 값은 'YYYY-MM-DD HH24:MI:SS' 구조를 갖을 경우
select * from orders where DATE(order_date) = '2025-08-01';
```

### 2.2.3 더 중요한 인덱스 사용 조건

인덱스를 Range Scan 하기 위한 가장 첫 번째 조건은 인덱스 선두 컬럼이 조건절에 있어야 한다.

```SQL
-- index (소속팀 + 사원명 + 연령)
-- 사용가능
select *
from emp
where 소속팀 = 'A'
and 사원명 like ('%길%');

-- 사용불가능
select *
from emp
where 사원명 like ('%길%')
and 소속팀;
```

위와 같이 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있으면 인덱스 Range Scan은 무조건 가능하다.

### 2.2.4 인덱스를 이용한 소트 연산 생략

인덱스를 제대로 사용했을 때 '=' 조건으로 검색을 한다면 데이터가 이미 정렬이 되어있는 상태임으로 ORDER BY 연산을 따로 수행하지 않아도 정렬되어 출력된다.

### 2.2.5 ORDER BY 절에서 컬럼 가공

```SQL
-- 인덱스 (장비번호, 변경일자, 변경순서)
select *
from 상태변경이력
where 장비번호 = 'C'
order by 변경일자, 변경순번
```

위 경우 자동으로 변경일자, 변경순번 순으로 정렬된다.

```SQL
-- 인덱스 (장비번호, 변경일자, 변경순서)
select *
from 상태변경이력
where 장비번호 = 'C'
order by 변경일자 || 변경순번
```

하지만 위와 같이 order by 절에 가공한 값이 들어간다면 정렬 연산 생략이 불가능하다.

### 2.2.6 SELECT-LIST에서 컬럼 가공

select 절에서도 마찬가지다.

```SQL
-- index (장비번호, 변경일자, 변경순번)
select MIN(변경순번) -- MAX(변경순번)
from 상태변경이력
where 장비번호 = 'C'
and 변경일자 = '00000000'
```

위와 같은 경우 변경순번에 정렬이 되어있음으로 최솟값 최댓값을 구하는데 정렬연산이 수행되지 않는다. 하지만 아래와 같이 가공이 들어간다면 정렬연산을 필요로 한다.

```SQL
-- index (장비번호, 변경일자, 변경순번)
select MAX(TO_NUMBER(변경순번))
from 상태변경이력
where 장비번호 = 'C'
and 변경일자
```

### 2.2.7 자동 형변환

```SQL
-- 생년월일 컬럼은 문자열 타입
-- index (생년월일)
select *
from 고객
where 생년월일 = 19951030
```

위 경우 옵티마이저는 자동으로 형변환을 진행한다.
`TO_NUMBER('생년월일') = 19951030`  
이렇게 형변환이 되었을 경우 인덱스 컬럼에 가공이 들어간 형태이기 때문에 당연하게도 인덱스를 타지 않는다.

- 위와 같은 형 변환은 다음과 같은 경우 발생한다.
  - 숫자 ↔ 문자열
  - DATE/DATETIME ↔ 문자열
  - DECIMAL ↔ FLOAT
  - CHAR ↔ VARCHAR, NCHAR ↔ NVARCHAR 등

## 2.3 인덱스 확장기능 사용법
- 인덱스 확장기능
    1. Index Range Scan
    2. Index Full Scan
    3. Index Unique Scan
    4. Index Skip Scan
    5. Inex Fast Full Scan

### 2.3.1 Index Range Scan
- 이전 챕터에서 나왔듯 수직으로 시작점을 찾은 후 수평으로 데이터를 탐색하는 방식
### 2.3.2 Index Full Scan
- 수직적 탐색없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식
- 이 방식은 최적의 인덱스가 없을 때 차선으로 선택된다
```SQL
-- index (ename, sal)
select *
from emp
where sal > 2000;
```
위 쿼리의 경우 선두 컬럼이 조건절에 없어 Range 탐색이 불가능 하나 sal 컬럼이 인덱스에 걸려있어 Full Scan이 가능하다.
#### Index Full Scan의 효용성
- 인덱스 선두컬럼이 없을 때, 옵티마이저는 다음과 같이 실행 계획을 구성한다.
1. Table Full Scan을 고려
2. 탐색하고자 하는 테이블이 대용량이면 Full Scan에 대한 부담이 크기에 옵티마이저는 인덱스 활용을 계획한다.
3. 이때 사용되는 탐색법이 Index Full Scan이다.
### 2.3.3 Index Unique Scan
- 수직적 탐색만으로 데이터를 찾는 방식으로 '='조건으로 탐색하는 경우 사용된다.
### 2.3.4 Index Skip Scan

복합 인덱스의 선두 컬럼을 조건절에 쓰지 않아도, 인덱스를 활용할 수 있게 해주는 최적화 기법이다.

- 일반적인 규칙에서는 인덱스 (A, B)가 있을 때,
- WHERE A = ? 조건이 없으면 보통 옵티마이저는 풀스캔을 선택한다
- 하지만 선두 컬럼의 distinct 값이 적고 후행 컬럼의 distinct 값이 많다면 Index Skip Scan을 사용하기 좋다

```SQL
-- index (gender, age)
select * from people where age = 30;
```

위 쿼리에서 선두 컬럼 gender가 없음으로 보통은 인덱스를 사용할 수 없다.
하지만 DB는 gender('M', 'F') 기준으로 M과 F를 **건너뛰며(skip)** `age=30`을 검색한다.
-> 결과적으로 풀스캔보다 효율적

#### Index Skip Scan이 작동하기 위한 조건

1. 복합 인덱스가 있어야 한다.(단일 인덱스는 해당 하지 않는다.)
2. 선두 컬럼에 조건이 없거나 넓은 범위를 갖어야 한다.
3. 선두 컬럼의 distinct 값이 적을 때 유리하다.
   - 성별, 지역코드(개수가 적을 경우), 상태코드(Y/N)
   - distinct 값이 많으면 사실상 skip scan이 아닌 풀스캔 수준이다.
4. 후행 컬럼에 조건이 존재해야 한다.
   - `where B = ?, B BETWEEN ... `
5. 옵티마이저가 해당 계획이 풀스캔보다 효율적이라고 판단되면 사용됨 혹은 사용자가 힌트를 주거나..

#### 해당 스캔 방식에 장단점

- 장점
  - 선두 컬럼 조건이 없어도 인덱스를 활용할 수 있다.
  - 소수의 distinct 값만 skip 하면 됨 -> 풀스캔보다 빠름
- 단점
  - 선두 컬럼의 distinct 값이 많으면 skip이 너무 많이 발생해 오히려 속도가 느리다
  - 이걸 쓸바엔 후행 컬럼에 인덱스를 걸어서 쓴다.

### 2.3.5 Index Fast Full Scan

- Index Full Scan은 인덱스의 논리적 구조를 따라 스캔한다.
- Index Fast Full Scan은 물리적으로 디스크에 저장된 순서대로 인덱스 리프 블록들을 읽어들인다.  
  |구분|Index Full Scan|Index Fast Full Scan|
  |---|---|---|
  |순서|인덱스 정렬된 상태로 읽기 때문에 순서 유지|블록을 기준으로 읽기 떄문에 순서가 보장이 안됨|
  |I/O방식|단일 블록, 순차적|멀티블록, 병렬 가능|
  |사용 목적|정렬/범위 검색|빠르게 전체 읽기|
  |속도|느림|빠름|

  > 출처 : https://gkscode.tistory.com/110

  ### 2.3.6 Index Range Scan Descending

  거꾸로 읽는 Index Range Scan
