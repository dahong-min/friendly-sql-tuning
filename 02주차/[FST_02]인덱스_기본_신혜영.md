# 2.1 인덱스 구조 및 탐색

## 2.1.1 미리보는 인덱스 튜닝

### 인덱스 튜닝의 두가지 핵심요소

- 인덱스 스캔 효울화 튜닝
    - 인덱스 스캔 과정에서 발생하는 비효율을 줄이는 것
- 랜덤 엑세스 최소화 튜닝
    - 테이블 액세스 횟수를 줄이는 것
    - 인덱스 스캔 후 테이블 레코드를 액세스할 때 랜덤 I/O 방식을 사용
- 둘 중에 중요한 것은 랜덤 엑세스 최소화 튜닝

### SQL 튜닝은 랜덤I/O와의 전쟁

- 데이터베이스 성능이 느린 이유
    - 디스크 I/O 때문

### 2.1.2 인덱스 구조

DBMS 는 일반적으로 B-Tree인덱스를 사용

**[B-Tree구조란?]**

B-Tree는 자식 2개만을 갖는 이진트리(Binary Tree)를 확장하여 N개의 자식을 가질 수 있도록 고안된 것이다. 좌우 자식 간의 균형이 맞지 않을 경우에 매우 비효율적이라 항상 균형을 맞춘다는 의미에서 균형트리(Balanced Tree)라고 부른다. 

B-Tree는 최상위에 단 하나만의 노드가 존재하고, 이를 루트(Root Node)라고 부른다. 중간 노드를 브랜치 노드(Brancch Node), 최하위 노드를 리프노드(Leaf Node)라고 한다. 

![image.png](attachment:f4a02165-37c4-41b0-8bce-d9d508d47d76:image.png)

- LMC(Leftmost Child)
    - 모든 노드는 LMC를 가지며, 루트와 브랜치(내부) 노드에서 LMC는 키 값이 아닌 자식 노드를 가리키는 포인터로서의 역할을 한다.
    - B-Tree 내부에서 자식 노드 중 가장 왼쪽 끝에 위치한 노드를 의미한다.

인덱스 탐색과정

- 수직적 탐색: 인덱스 스캔 시작지점을 찾는과정
- 수평적 탐색: 데이터를 찾는과정

### 2.1.3 인덱스 수직적 탐색

루트(Root) 블록에서부터 시작

찾고자 하는 값보다 크거나 같은 값을 만나면 바로 직전 레코드가 가리키는 하위블록으로 이동 → 루트를 포함하여 브랜치(Branch) 블록에 저장된 각 인덱스 레코드에 하위 블록에 대한 주소값을 갖기때문

- 조건을 만족하는 첫번째 레코드를 찾는 과정

### 2.1.4 인덱스 수평적 탐색

수직적 탐색을 통해 스캔 시작점을 찾았으면, 찾고자 하는 데이터가 더 안나타날 떄까지 덱스 리프 블록을 수평적으로 스캔한다. 

- 인덱스를 수평적으로 탐색하는 이유
    - 조건절을 만족하는 데이터를 모두 찾기위해
    - ROWID를 얻기 위하여

### 2.1.5 결합 인덱스 구조와 탐색

인덱스는 마치 엑셀의 데이터 필터기능

# 2.2 인덱스 기본 사용법

인덱스 기본 사용법은 Index Range Sacn 하는 방법을 의미한다. 

### 2.2.1 인덱스를 사용한다는 것

- 인덱스 컬럼을 가공하지 않아야 인덱스를 정상적으로 사용할 수 있다.
- 인덱스를 정상적으로 사용한다는 의미
    - 리프 블록에서 스캔 시작점을 찾아 거기서부터 스캔하다가 중간에 멈추는 것을 의미 → 리프 블록만 일부 스캔
    - Index Full Scan 방식

### 2.2.2 인덱스를 Range Scan할 수 없는 이유

- 인덱스 컬럼을 가공했을 때 인덱스 스캔 시작점을 찾을 수 없기 때문이다.
- Index Rande Sacn은 인덱스에서 일정 범위를 스캔한다는 의미
- Or Expansion
    - 아래와 같이 고객명, 전화번호 인덱스 각각에 대해 사용가능
    - OR 또는 IN조건 절은 옵티마이저의 쿼리 변환 기능을 통해 Index Range Scan으로 처리되기도한다.
        
        ```sql
        select *
        from 고객
        where 고객명 = :cust_nm  -- 고객명이 선두 컬럼인 인덱스 Range Scan
        union all
        select *
        from 고객
        where 전화번호 = :tel_no -- 전화번호가 선두 컬럼인 인덱스 Range Scan
        and (고객명 <> :cust_nm or 고객명 is null)
        ```
        

### 2.2.3 더 중요한 인덱스 사용 조건

- 인덱스 선두 컬럼이 조건절에 있어야한다.
- 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있으면 인덱스 Range Scan은 가능하다.
- 인덱스를 잘 타지만, 스캔 범위를 줄이지 못하는 경우 → 인덱스 리프 블록에서 스캔하는 양이 많음 → 인덱스를 타더라도 느릴 수 있음
    
    ```sql
    /* 인덱스 = [주문일자 + 상품번호] */
    /* CASE1)
    중간값 검색 경우 -> 스캔범위를 줄이지 못함 */
    SELECT * 
    FROM 주문상품
    WHERE 주문일자 = :ord_dt
    AND 상품번호 LIKE '%PING%';
    
    /* CASE2)
    컬럼을 가공한 경우 -> 스캔범위를 줄이지 못함 */
    SELECT * 
    FROM 주문상품
    WHERE 주문일자 = :ord_dt
    AND SUBSTR(상품번호, 1, 4) = 'PING'';
    ```
    

# 2.3 인덱스 확장기능 사용법

### 

### 그래서 뭘 줄여야 하나?

### 1) 인덱스 “스캔 범위”를 줄이기

- **선두 컬럼 선택도 높이기**: 복합 인덱스의 **컬럼 순서**를 자주 쓰는 조건/선택도 높은 것 → 낮은 것 순으로.
- **SARGable로**: 컬럼 가공(함수/형변환) 제거, 범위/등호 비교로 바꾸기.
- **파티션 프루닝**: 먼저 큰 덩어리를 잘라낸 후 인덱스 범위를 좁히기.
- **부분(Partial) 인덱스/조건부 인덱스(Postgres)**: 자주 조회하는 활성 구간만 인덱싱.

### 2) “테이블 액세스 횟수”를 줄이기

- **커버링 인덱스**: 필요한 컬럼을 인덱스에 포함 → **table lookup 제거**
    - MySQL: 복합키/생성열 활용, SQL Server: `INCLUDE`, Postgres: 표현식/다중컬럼 인덱스.
- **Index-Only Scan**: (PG) Visibility Map, (ORACLE) IOT/클러스터 인덱스, (MySQL) 커버링.
- **클러스터링/정렬 상관성**: 인덱스 순서와 테이블 물리 배치가 비슷하면 룩업 시 **페이지 재사용**이 늘어나 랜덤 I/O 감소.
    - InnoDB는 PK 기준 클러스터, Postgres `CLUSTER`/`pg_repack` 고려.
- **불필요 컬럼 SELECT 자제**: 꼭 필요한 것만 선택해 커버링이 되게 하거나, 적어도 테이블 방문을 줄이기.

### 같은 조건, 다른 성능 — 직관적 예

- 테이블 1천만 행, 인덱스 `(user_id, created_at)`
- 쿼리 A:
    
    ```sql
    SELECT *
    FROM orders
    WHERE user_id = 42 AND created_at >= '2025-09-01';
    
    ```
    
    - **스캔 범위:** `(42, 2025-09-01)`부터의 짧은 꼬리.
    - **테이블 접근:** 라서 테이블 룩업 필요(커버링 아님). 건수 적으면 OK.
- 쿼리 B (비슷해 보이지만 느릴 수 있음):
    
    ```sql
    SELECT *
    FROM orders
    WHERE created_at >= '2025-09-01';
    
    ```
    
    - 선두 `user_id` 조건이 없어 **범위가 폭발** → 인덱스 리프를 광범위 스캔 + 테이블 룩업 폭증 → 풀스캔이 더 빠를 수도.
- 쿼리 C (커버링):
    
    ```sql
    SELECT user_id, created_at, status   -- 인덱스에 포함된 컬럼만
    FROM orders
    WHERE user_id = 42 AND created_at >= '2025-09-01';
    
    ```
    
    - **Index-Only/커버링**이면 테이블 룩업 0 → 대개 A보다 훨씬 빠름.
