# 3. 인덱스 튜닝

### 3.1 테이블 엑세스 최소화
#### 3.1.1 테이블 랜덤 엑세스
 인덱스 스캔을 하는 이유는 ? 
검색 조건을 만족하는 소량의 데이터를 인덱스에서 빨리 찾고, 레코드를 찾아가기 위한 주소 값 ROWID를 얻으려는 데 있다.

- 인덱스 ROWID는 논리적 주소값에 가깝다.
- 물리적으로 직접 연결되어 있지 않고, 레코드를 찾아가기 위한 논리적 주소 정보를 담고 있기 때문이다.
- 프로그래밍 언어에서 포인터와는 다르다. 오라클은 테이블 블록이 수시로 버퍼캐시에 밀려났다가
다시 캐싱 되고, 그때마다 다른 공간에 캐싱 되기 때문에 인덱스에 포인터로 직접 연결할 수 없는 구조다.
- 메모리 주소 정보가 아닌 디스크 주소 정보를 이용해 해시 알고리즘으로 버퍼 블록을 찾아간다.
> 일반 DBMS에서 인덱스 ROWID를 이용한 테이블 엑세스가 생각만큼 빠르지 않은 이유다.

#### 인덱스 클러스터링 팩터
클러스터링 팩터(CF:Clustering Factor) : 특정 칼럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도
> CF가 좋은 칼럼에 생성한 인덱스는 검색 효율이 높음 
예시) 열 명의 자녀가 모여 살면, 부모님은 자녀의 집을 방문하는데 하루면 충분함, 흩어져 살면 얼마나 걸릴지 모름

인덱스를 이용한 테이블 엑세스가 Table Full Scan보다 더 느려지게 하는 요인
1. Table full scan은 시퀀셜 액세스인 반면, rowid를 이용한 것은 랜덤액세스 방식
2. Table Full Scan은 Multiblock I/O인 반면, 인덱스 ROWID를 이용한 액세스는 Single Block I/O  방식

#### 온라인 프로그램 튜닝 VS 배치프로그램 튜닝
 여기서 배치프로그램은 대량의 데이터를읽고 가공해서 다른 테이블에 입력하거니, 일괄 수정/삭제 하는 프로그램을 말함.

##### 온라인 프로그램
- 보통 소량의 데이터를 읽고 갱신 > NL 조인, 인덱스를 효과적으로 사용하는 것이 중요함
##### 배치프로그램 튜닝
- 대량의 데이터를 읽고 갱신하기 때문에 Full Scan,해시 조인이 유리함
- 초대량 테이블이라면 파티션 활용 전략이 중요한 튜닝요소임 + 병렬처리까지 한다면 굿

### 인덱스 컬럼 추가
 테이블 엑세스 단계 필터 조건에 의해 버려지는 레코드가 많을 때
```
[DPEPTNO + JOB]

SELECT /*+INDEX(EMP EMP_X01) */*
  FROM EMP
WHERE DEPTNO = 30
AND SAL >=2000


기존 인덱스에 SAL 인덱스를 추가함으로써, 인덱스 스캔량은 줄지않지만, 테이블 랜덤 엑세스 횟수를 줄여줄 수 있다.

```

### 인덱스만 읽고 처리[Covered Index]
필터 조건에 의해서 버려지는 컬럼이 없을 때

```
[부서번호]

SELECT 부서번호, SUM(수량)
  FROM 판매집계
WHERE 부서번호 LIKE '12%'
GROUP BY 부서번호;

인덱스 스캔 과정에서 얻은 데이터가 많다면 그만큼 랜덤 엑세스가 많이 존재하므로 성능이 좋지않다.
반드시 성능 개선을 한다면, 쿼리에 사용한 모든 컬럼을 인덱스에 추가 하는 방법이 있다.
하지만 이 방법을 적용하기 어려운 경우도 있다.

* Include Index : 랜덤 엑세스를 줄이는 용도
인덱스 키외에 미리 지정한 컬럼을 리프 레벨에 함께 저장하는 방식.
인덱스를 생성할 때 옵션을 지정, 컬럼 최대 1023개 까지 가능

CREATE INDEX  EMP_X01 ON EMP (DEPTNO) INCLUDE (SAL);

CREATE INDEX  EMP_X02 ON EMP (DEPTNO,SAL);

EMP_X01 [Include Index]: 수직적 탐색에는 DEPTNO 만 사용, 수평적 탐색시 DEPTNO,SAL , 소트연산 생략 불가

```

#### 인덱스 구조 테이블

인위적으로 클러스터링 팩터를 좋게 많드는 방법
테이블 블록에 있어야 할 데이터를 모두 인덱스 리프 블록에 모두 저장

```
CREATE TABLE INDEX_ORG_T (A NUMBER, B VARCHAR(10)
	, CONSTRAINT INDEX_ORG_T_PK PRIMARY KEY (A) )
ORGANIZATION INDEX;

일반 테이블은 힙 구조 테이블 이라고 한다.

CREATE TABLE HEAP_ORG_T (A NUMBER, B VARCHAR(10)
	, CONSTRAINT INDEX_ORG_T_PK PRIMARY KEY (A) )
ORGANIZATION HEAP; -- 옵션 명시 가능함

힙 구조 테이블에서는 데이터를 입력할때 랜덤방식 
Freelist로 부터 할당 받은 블록에 정해진 순서없이 입력함
인덱스 구조 테이블은 정렬 상태를 유지하면서 데이터 입력함
100% 정렬된 상태로 모여있기때문에 랜덤엑세스가 아닌 시퀀셜 엑세스로 데이터 엑세스
BETWEEN이나 부등호 조건으로 넒은 범위를 읽을때 유리함
```
#### 클러스터 테이블

##### 인덱스 클러스터 테이블
클러스터 키 값이 같은 레코드를 한 블록에 모아서 저장하는 구조
한 블록에 담을 수 없다면 새로운 블록에 할당해서 클러스터 체인으로 연결함

```
CREATE CLUSTER C_DEPT#(DEPTNO NUMBER(2)) INDEX;
* 클러스터를 먼저 생성해야함,데이터 검색용도 뿐만 아니라 데이터가 저장될 위치를 찾을때도 사용하기때문이다.
CREATE INDEX C_DEPT#_IDX ON CLUSTER C_DEPT#;

CREATE TABLE DEPT
 (DEPTNO NUMBER(2) NOT NULL,
  DNAME VARCHAR2(14) NOT NULL,
  LOC VARCHAR2(13))
CLUSTER C_DEPT#(DEPTNO);

```
클러스터 인덱스도 B*Tree 인덱스구조를 사용하지만,테이블 레코드를 일일이 가리키지않고 
해당 키값을 저장하는 첫번째 데이터 블록을가리킨다는 점이 다르다.
클러스터 인덱스는 1:M 관계를 갖는다.클러스터 인덱스의 키 값은 항상 Unique 하다.
그래서서, 클러스터 인덱스를 스캔하면서 값을 찾을때는 값 하나당 한 번씩 밖에 발생하지 않는다.

##### 해시 클러스터 테이블

인덱스를 사용하지 않고 해시 알고리즘을 사용해서 클러스터를 찾아간다.

```
CREATE CLUSTER C_DEPT#(DEPTNO NUMBER(2)) HASHKEYS 4;

CREATE TABLE DEPT
 (DEPTNO NUMBER(2) NOT NULL,
  DNAME VARCHAR2(14) NOT NULL,
  LOC VARCHAR2(13))
CLUSTER C_DEPT#(DEPTNO);


```

? 주의점
1. DML 성능 저하 (특히 INSERT/UPDATE)
2. 클러스터 키 분포가 고르지 않으면 공간 낭비
3. 규칙기반 옵티마이저 기준 클러스터를 우선시 한다.

 >데이터가 많고, 특정 키값으로 넓은 범위를 자주 조회하며, 클러스터 키로 사용할 컬럼의 값이 거의 변경되지 않을 때 적합하다.


---
### 3.2 부분범위 처리 활용

##### 부분범위 처리

>전체 쿼리 결과 집합을 쉼 없이 연속적으로 전송하는 것이 아니라 사용자로부터 Fetch Call이 있을 때마다 일정량 씩 나누어서 전송하는 것

```
1. 최초 rs.next() 호출 시 Fetch Call을 통해 DB 서버로부터 전송받은 데이터 10건을 클라이언트 캐시에 저장한다.
2. 이후 rs.next() 호출할 때는 Fetch Call을 발생시키지 않고 캐시에서 데이터를 읽는다.
3. 캐시에 저장한 데이터를 모두 소진한 상태에서 rs.next() 호출 시 추가 Fetch Call을 통해 10건을 전송받는다.
4. 100건을 다 읽을 때까지 2~3번 과정을 반복한다.

```

정렬 조건이 있을 때
```
ResultSet rs = stmt.executeQuery('select name from bit_table order by created')
```

정렬 조건이 있다면 '모든' 데이터를 읽고 created순으로 로 정렬을 마치고 난 뒤에 데이터를 전송할 수 있다. 
전체범위 처리다. 정렬 조건이 선두에 있는 인덱스가 있다면 부분 범위 처리가 가능하다. 인덱스는 항상 정렬된 상태를 유지하므로
Array Size 조정을 통해서 Fetch Call 횟수를 줄 일 수있다.


#### OLTP 환경에서 부분범위 처리에 의한 성능개선 원리
OLPT, Online Transaction Processing 온라인 트랜잭션을 처리하는 시스템

OLPT는 대부분 소량 데이터를 읽고 갱신하지만, 항상 그렇지는 않다.
이럴 때 인덱스를 사용하면 테이블 랜덤 엑세스가 발생하여 만족할 만한 성능을 내지못할 수 있다. 
업무에서 결과가 많더라도, 사용자는 모든 데이터를 다 확인하지 않고, 특정한 정렬 순서에 따라 상위 일부만 확인한다. 
이 때 정렬 상태를 유지하는 인덱스를 사용하면, 정렬 작업을 생략하고 앞쪽 일부 데이터만 먼저 빠르게 보여주므로써 성능 개선 효과를 보여 줄 수 있다.

>부분범위 처리의 핵심은 앞쪽 일부만 출력하고 멈출수 있는가이다.
