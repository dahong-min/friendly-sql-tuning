# 3장. 인덱스 튜닝
## 3.1 테이블 액세스 최소화
### 3.1.1 테이블 랜덤 액세스
- 인덱스에 대한 맹신 또는 섣부른 자신감
  - 파티션 Pruning : 조건절에 해당하는 파티션만 읽는 기능
  - 인덱스를 이용해도 조건절에 해당하는 데이터만 골라서 읽는데, 파티션 Pruning이 왜 필요할까 ?
  - 대량 데이터를 조회할 때 인덱스를 사용하면 테이블 전체를 스캔할 때보다 훨씬 느리다.
- 인덱스 ROWID는 물리적 주소? 논리적 주소?
  - SQL이 참조하는 컬럼을 인덱스가 모두 포함하는 경우가 아니면, 인덱스를 스캔한 후에 반드시 테이블을 액세스 => TABLE ACCESS BY INDEX ROWID(실행계획)
  - 인덱스를 스캔하는 이유 => 검색 조건을 만족하는 소량의 데이터를 인덱스에서 빨리 찾고 거기서 테이블 레코드를 찾아가기 위한 주소값(ROWID) 얻기 위함
  - 인덱스 ROWID는 데이터파일 번호, 오브젝트 번호, 블록 번호 같은 물리적 요소로 구성 BUT 논리적 주소에 가까움, 디스크 상에서 테이블 레코드를 찾아가기 위한 위치 정보를 담음
- 메인 메모리 DB와 비교
  - 메인 메모리 DB(MMDB) : 데이터를 모두 메모리에 로드해 놓고 메모리를 통해서만 I/O를 수행하는 DB
  - 잘 튜닝된 OLTP성 데이터베이스 시스템 : 버퍼캐시 히트율 99% 이상 => 디스크를 경유하지 않고 대부분 데이터를 메모리에서 읽음 BUT MMDB많큼 빠르지 않음  
  WHY?
  - MMDB의 경우 디스크 저장 데이터를 버퍼캐시에 이동 후 인덱스를 생성해서, 인덱스에 디스크상 주소 정보가 아니라 메모리상 주소 정보를 저장해서 빠름
  - 오라클은 인덱스에서 포인터로 직접 연결할 수 없는 구조 => 디스크 주소 정보를 이용해 해시 알고리즘으로 버퍼블록 찾아가서 훨씬 느림  
  => 즉 일반 DBMS에서 인덱스 ROWID를 이용한 테이블 액세스가 생각보다 빠르지 않음
- I/O 메커니즘 복습
  - I/O 성능을 높이려면 버퍼캐시를 활용해야 함 => 블록을 읽을 때 디스크로 가기 전에 버퍼캐시부터 찾고, 읽고자하는 DBA를 해시 함수에 입력하여 해시 체인을 찾고 거기서 버퍼 헤더를 찾음
  - 
