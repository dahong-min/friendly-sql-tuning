## 3.3 인덱스 스캔 효율화

IOT, 클러스터, 파티션은 테이블 랜덤 액세스를 최소화 하는 데 매우 효과적인 저장 구조이지만, 성능 검증을 위해 많은 테스트를 진행해야 함으로 시스템 개발 단계에서 물리 설계가 중요하다.

### 3.3.1 인덱스 탐색

![alt text](./FST_04/image.png)  
위 구조를 가진 인덱스에서 아래 조건절을 처리할 때, 스캔 시작지점과 종료지점이 어디일까?

```SQL
1. WHERE C1 = 'B'
    -> 리프 블록 2 ~ 3
2. WHERE C1 = 'B' AND C2 = 3
    -> 리프 블록 2 ~ 3
3. WHERE C1 = 'B' AND C2 >= 3
    -> C1 = 'C'인 레코드를 만나는 지점
    -> C2 >= 3 은 종료지점을 찾는데 아무 역할을 하지 않았지만, 시작지점을 찾는데 중요한 역할을 함
4. WHERE C1 = 'B' AND C2 <= 3
    -> C2 > 3 인 레코드를 만나는 지점
    -> C2 <= 3 은 시작지점을 찾는데 아무 역할을 하지 않았지만, 종료지점을 찾는데 중요한 역할을 함
5. WHERE C1 = 'B' AND C2 BETWEEN 2 AND 3
    -> 리프 블록 2 ~ 3
6. WHERE C1 BETWEEN 'A' AND 'C' AND C2 BETWEEN 2 AND 3
    -> C1은 스캔 시작과 끝 지점을 결정하는 중요한 역할을 함
```

### 3.3.2 인덱스 스캔 효율성

### 3.3.3 액세스 조건과 필터 조건

인덱스 스캔 효율성을 설명하기 전에 두가지 조건을 이해해야 함

- 인덱스 스캔 단계
  - 인덱스 액세스 조건 : 인덱스 수직적 탐색을 통해 스캔 시작점을 결정하고 인덱스 리프 블록 스캔 중 어디서 멈출지를 결정
  - 인덱스 필터 조건 : 테이블로 액세스 할지를 결정
- 테이블 액세스 단계
  - 테이블 필터 조건 : 쿼리 수행 다음 단계로 전달하거나 최종 결과집합에 포함할지를 결정

### 3.3.4 비교 연산자 종류와 컬럼 순서에 따른 군집성

- 테이블과 달리 인덱스는 정렬이 되어 있기에 데이터들이 서로 군집해 있다

![alt text](./FST_04/3-31.png)

```SQL
1. WHERE C1 = 1 AND C1 = 'A' AND C3 = '나' AND C4 = 'a'
2. WHERE C1 = 1 and C2 = 'A' and C3 = '나' and C4 >= 'a'
3. WHERE C1 = 1 and C2 = 'A' and C3 between '가' and '다' and C4 = 'a'
4. WHERE C1 = 1 and C2 <= 'B' and C3 = '나' and C4 between 'a' and 'b'
5. WHERE C1 between 1 and 3 and C2 = 'A' and C3 = '나' and C4 = 'a'
```

### 3.3.5 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율

인덱스 스캔 효율성은 인덱스 컬럼을 조건절에 모두 등치(=) 조건으로 사용할 때 가장 좋다.  
인덱스가 [아파트시세코드 + 평형 + 평형타입 + 인터넷매물] 순으로 고성되어 있다면 아래의 경우 모두 인덱스 액세스 조건으로 사용되어 비효율이 없다.

```SQL
where 아파트시세코드 = :a
where 아파트시세코드 = :a and 평형 = :b
where 아파트시세코드 = :a and 평형 = :b and 평형타입 = :c
where 아파트시세코드 = :a and 평형 = :b and 평형타입 between :c and :b
```

반면 위와 다르게 인덱스 선행컬럼이 조건절에 없거나 `BETWEEN, LIKE`와 같은 범위검색 조건이 들어가면 비효율이 발생할 수 있다.

### 3.3.6 BETWEEN을 IN-List로 전환

범위검색 컬럼이 맨 뒤로 가도록 인덱스를 변경한다면 가장 좋은 효과를 얻을 수 있겠지만, 실제 운영환경에서 인덱스를 변경하는 것은 역효과가 클 수 있기 때문에 쉽지 않다.  
위와 같은 경우 범위검색은 IN-List로 변경하면 큰 효과를 얻을 수 있다.

만약 IN-List의 항목이 늘어날 수 있다면 Index Skip Scan을 사용할 수 있도록 유도하는 방식을 사용할 수 있다.

#### BETWEEN 조건을 IN-List로 전환할 때 주의 사항

- IN-List의 개수가 많으면 안된다.  
  개수가 많으면 블록을 반복 탐색하는 비효율이 커지므로 속도가 느려질 수 있어 주의해야 한다.

### 3.3.7 Index Skip Scan 활용

Index Skip Scan의 활용으로 반복조건을 IN-List로 변환하는 것과 같은 효과를 낼 수 있다.

```SQL
select count(*)
from 월별고객별판매집계 t
where 판매구분 = 'A'
and 판매월 between '201801' and '201812'


select /*+ INDEX_SS(t 월별고객별판매집계_IDX2) */ count(*)
from 월별고객별판매집계 t
where 판매구분 = 'A'
and 판매월 between '201801' and '201812'
```

### 3.3.8 IN 조건은 '='인가

IN 조건은 '='이 아니다. IN 조건이 '='이 되려면 IN-List Iterator 방식으로 풀려야한다.  
그렇지 않으면 IN 조건은 필터 조건이 된다.  
IN-List Iterator : IN에 들어있는 값 각각을 대상으로 Index Scan을 여러 번 수행하고, 결과를 합치는(iterate) 형태

| 구분                   | Index Range Scan               | IN-List Iterator                    |
| ---------------------- | ------------------------------ | ----------------------------------- |
| 동작                   | 한 구간(range)을 연속으로 스캔 | 여러 range를 반복적으로 스캔        |
| 사용 예                | BETWEEN, >=, < 등              | IN (...) 조건                       |
| 실행 횟수              | 1회                            | IN 리스트 개수만큼 반복             |
| 효율                   | 연속 구간에 유리               | 소수의 IN 값에 유리                 |
| 실행계획 표시 (Oracle) | INDEX RANGE SCAN               | INDEX RANGE SCAN + IN-LIST ITERATOR |

### 3.3.9 BETWEEN과 LIKE 스캔 범위 비교

## 3.4 인덱스 설계

### 3.4.1 인덱스 설계가 어려운 이유

인덱스가 많아지면 다음과 같은 관리비용으로 인해 시스템 부하를 증가시킨다.

- DML 성능 저하(-> TPS 저하)
- 데이터베이스 사이즈 증가(-> 디스크 공간 낭비)
- 데이터베이스 관리 및 운영 비용 상승

예를 들어 한 테이블에 6개의 인덱스가 있다면 데이터가 삽입 및 삭제될 경우 해당 데이터에 대해 6개의 인덱스를 정의해야 한다.

### 3.4.2 가장 중요한 두 가지 선택 기준

1. 조건절에 항상 사용하거나, 자주 사용하는 컬럼을 선정한다.
2. '=' 조건으로 자주 조회하는 컬럼을 앞쪽에 둔다.

### 3.4.3 스캔 효율성 이외의 판단 기준

위 공식 이외에 고려해야 할 판단 기준은 다음과 같다.

- 수행 빈도
- 업무상 중요도
- 클러스터링 팩터
- 데이터량
- DML 부하(= 기존 인덱스 개수, 초당 DML 발생량, 자주 갱신하는 컬럼 포함 여부 등)
- 저장 공간
- 인덱스 관리 비용 등

### 3.4.4 공식을 초월한 전략적 설계

INSERT가 많이 일어나는 테이블의 경우 다음과 같은 전략적 설계가 이루어질 수 있다.  
-> 일자/일시 조건을 선두에 두고, 자주 사용하는 필터 조건을 모두 뒤쪽에 추가하는 방식이다.  
이렇게 설계한 핵심 포인트는 다음과 같이 두가지다.

1. 일자 조회구간이 길지 않으면 인덱스 스캔 비효율이 성능에 미치는 영향이 크지 않다는 점이다.
2. 인덱스 스캔 효율보다 테이블 액세스가 더 큰 부하요소라는 점이다.

이러한 점을 고려하면 무수하게 많이 늘어날 수 있는 인덱스를 최소한으로 줄일 수 있다.

### 3.4.5 소트 연산을 생략하기 위한 컬럼 추가

I/O를 최도화 하면서 소트 연산을 생략하려면, 아래 공식에 따라 인덱스를 구성하면 된다.

1. '=' 연산자로 사용한 조건절 컬럼 선정
2. ORDER BY 절에 기술한 컬럼 추가
3. '=' 연산자가 아닌 조건절 컬럼은 데이터 분포를 고려해 추가 여부 결정

### 3.4.6 결합 인덱스 선택도

인덱스 생성 여부를 결정할 때는 선택도가 충분히 낮은지가 중요한 판단기준이다.

> 선택도 : 전체 레코드 중에서 조건절에 의해 선택되는 레코드 비율을 말하며, 선택도에 총 레코드 수를 곱해서 '카디널리티'를 구한다.

선택도가 높은(카디널리티가 높은) 인덱스는 생성해봐야 효용가치가 별로 없다.

#### 컬럼 순서 결정 시, 선택도 이슈

인덱스 생성 여부를 결정할 떄는 선택도가 매우 중요하지만, 컬럼 간 순서를 결정할 때는 각 컬럼의 선택도보다 필수 조건 여부, 연산자 형태가 더 중요한 판단 기준이다.

### 3.4.7 중복 인덱스 제거

#### 중복제거 실습1

- PK : 거래일자 + 관리지점번호 + 일련번호
- N1 : 계좌번호 + 거래일자
- N2 : 결제일자 + 관리지점번호
- N3 : 거래일자 + 종목코드
- N4 : 거래일자 + 계좌번호

-> 거래일자, 결제일자는 항상 BETWEEN 또는 부등호로 조회한다.

- PK : **관리지점번호** + 관리지점번호 + 일련번호
- N1 : 계좌번호 + 거래일자
- N2 : 결제일자 + 관리지점번호
- N3 : 거래일자 + 종목코드
- ~~N4 : 거래일자 + 계좌번호~~

> 하지만 GPT에 물어보니 해당 경우에는 중복된 인덱스가 없으니 삭제하면 안된다고 함

#### 중복제거 실습2

- PK : 주소ID + 건물동번호 + 건물호번호 + 관리번호
- N1 : 상태구분코드 + 관리번호
- N2 : 관리번호
- N3 : 주소ID + 관리번호

...

- PK : 주소ID + 건물동번호 + 건물호번호 + 관리번호
- N1 : 관리번호 + 상태구분코드
- ~~N2 : 관리번호~~
- N3 : 주소ID + 관리번호

> 위 실습의 경우는 GPT도 동일 답변을 함

### 3.4.8 인덱스 설계도 작성
