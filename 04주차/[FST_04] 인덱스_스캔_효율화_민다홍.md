### 3.3 인덱스 스캔 효율화

>인덱스 선행 컬럼이 조건절이 없거나, '=' 조건이 아니면, 인덱스 스캔에 비효율이 발생한다.

[선행컬럼] 어떤 컬럼보다 상대적으로 앞쪽에 놓인 컬럼

#### 엑세스 조건과 필터 조건

##### 엑세스 조건
인덱스 스캔 범위를 결정하는 조건절
인덱스 수적적 탐색을 통해 스캔 시작점을 결정하는 데 영향을 미치고, 인덱스 리프 블록을 스캔하다가 어디서 멈출지를 결정하는 조건절

##### 인덱스 필터 조건
테이블로 엑세스할지를 결정하는 조건절

##### 테이블 필터 조건
쿼리 수행 다음 단계로 전달하거나 최종결과 집합에 포함할지를 결정
인덱스를 사용하든, Full Scan을 사용하든 테이블 액세스 단계에서는 처리되는 조건절

#### 비교 연산자에 따른 군집성

선행 컬럼이 모두 '=' 조건인 상태에서 첫 번째 나타나는 범위검색 조건까지만 만족하는 인덱스 레코드는 모두 연속해서 모여 있지만, 그 이하 조건까지 만족하는 레코드는 비교 연산자에 상관없이 흩어진다.
첫 번째 나타나는 범위 조건까지가 인덱스 액세스 조건이고, 나머지는 필터조건이다.
가장 선두 칼럼이 범위 검색 조건이면, 그 조건이 스캔 범위를 결정하고, 나머지는 인덱스 칼럼 조건은 필터 조건이 된다. 

```
<조건절 1>
WHERE C1 = 1
AND C2 ='A'
AND C3 ='나'
AND C4 ='a'

<조건절 2>
WHERE C1 = 1
AND C2 ='A'
AND C3 ='나'
AND C4 >='a'

<조건절 3>
WHERE C1 = 1
AND C2 <='B'
AND C3 ='나'
AND C4 'a' BETWEEN 'b'

<조건절 4>
WHERE C1 BETWEEN 1 AND 3
AND C2 ='A'
AND C3  
AND C4 ='a'

```

|  | 인덱스 엑세스 조건 | 인덱스 필터 조건 |
|----------|---------------------|---------------------------|
| 조건절 1 | C1,C2,C3,C4|  |
| 조건절 2 | C1,C2,C3,C4 |  |
| 조건절 3 |C1,C2 | C3,C4 |
| 조건절 4| C1 | C2,C3,C4 |


##### BETWEEN을 IN-LIST로 전환

운영 시스템에서 인덱스구성을 바꾸기는 쉽지않다. BETWEEN 조건을 IN-LIST로 바꿔주면 큰 효과를 얻는 경우가 있다.


```
SELECT 해당층, 평당가, 입력일
FROM 매물 아파트 매매
WHERE 인터넷 매물 IN ('1','2','3')
AND 아파트시세코드 ='A123'
AND 평형 ='59'

인덱스 수직적 탐색은 세 번 발생한다.
IN-LIST 개수만큼 UNION ALL 브랜치가 생성되고 
각 브랜치마다 모든 칼럼을 '=' 조건으로 검색하므로 선두 컬럼에 BETWEEN을 사용할 대와 같은 비효율은 사라진다.

```
##### BETWEEN 조건을 IN-LIST로 전환할 때 주의사항
IN-LIST 개수가 많지 않아야한다. 많으면 수직적 탐색이 많이 발생한다.
인덱스 스캔 과정에서 선택되는 레코드들이 서로 멀리 떨어져 있을 때만 유용하다.



#####  BETWEEN과 LIKE 스캔 범위 비교

BETWEEN 조건을 사용하는 것이 더 낫다.

```

<조건절1>
SELECT * FROM 월별고객판매집계 
WHERE 판매월 LIKE '2019%'
AND 판매구문 'A'

<조건절2>
SELECT * FROM 월별고객판매집계 
WHERE 판매월 BETWEEN '201901' AND '201912'
AND 판매구문 'A'

조건절1 경우, '201900' 과 값이 저장되어있다면그 값도 읽어야해서, 판매구문 'A' 지점으로 바로 내려갈 수 없다. 

```

#### 다양한 옵션 조건 처리 방식의 장단점 비교

##### OR 조건 활용

인덱스 선두 칼럼에 대한 옵션 조건에 OR 조건을 사용해서는 안된다. 

* 옵티마이저에 의한 OR Expansion 쿼리 변환이 기본적으로 작동하지 않음

```
SELECT * FROM 거래
WHERE (:cust_id is null OR 고객ID = :cust_id)
AND 거래일자 BETWEEN :dt1 AND :dt2

인덱스에 포함되지 않은 칼럼에 옵션 조건은 어차피 테이블에서 필터링할 수밖에 없으므로 OR 조건을 사용해도 무방하다.
1. 인덱스 액세스 조건으로 사용 불가
2. 인덱스 필터 조건으로도 사용 불가
3. 테이블 필터 조건으로만 사용가능
4. 인덱스 구성 컬럼 중 하나 이상이 Not Null 칼럼이면, 18c부터 인덱스 필터 조건으로 사용 가능

OR 조건은 가급적 사용하지 않아야 한다.
장점은 옵션 조건컬럼이 NULL 허용 컬럼이더라도 결과 집합을 보장한다는 것이다.

```
##### LIKE/BETWEEN 조건 활용
>필수 조건 칼럼을 인덱스 선두에 두고 액세스 조건으로 사용하면, LIKE/BETWEEN이 인덱스 필터 조건이어도 충분히 좋은 성능을 낼 수 있다. 

XXX 사용하지 않아야 하는 경우

1. 인덱스 선두 칼럼에 대한 옵션 조건으로 LIKE/BETWEEN 

```
인덱스 [고객ID + 거래일자]
SELECT * FROM 거래
WHERE 고객ID LIKE :cust_id || '%'
AND 거래일자 BETWEEN :dt1 AND :dt2

만약 사용자가 고객 ID 값을 입력하지 않으면 인덱스에서 모든 데이터 값을 스캔하면서 거래일자 조건을 필터링 하는 불상사가 생긴다.
옵션 처리 조건에 LIKE/BETWEEN 을 사용 했다면 [거래일자 + 고객ID] 순으로 구성해야 한다. 
하지만 고객ID 값이 입력되었을 때 생기는 비효율을 감수해야 한다. 거래일자 범위에 속한 모든 거래 데이터를 스캔하면서 고객ID를 스캔하기때문이다.

```

2. NULL 허용 칼럼에 대한 옵션조건으로 LIKE/BETWEEN

```
SELECT * FROM 거래
WHERE 고객ID LIKE '%'
AND 거래일자 BETWEEN :dt1 AND :dt2

결과 집합에 오류가 생긴다.
거래일자 조건에 해당하는 모든 고객의 거래를 선택해야 하는 상황인데, 고객ID가 NULL 허용컬럼이고 실제 NULL 값이 입력되어 있다면 그 데이터는 결과집합에 누락된다.

```

3. 숫자형이면서 인덱스 액세스 조건으로도 사용 가능한 칼럼에 대한 옵션 조건으로 LIKE 사용해선 안된다.


```

인덱스 [거래일자 + 고객ID]

SELECT * FROM 거래
WHERE 거래일자 = :trd_dt
AND 고객ID LIKE :cust_id || '%'

cust_id에 값을 입력했을 때, 두 칼럼 모두 인덱스 액세스 조건으로 사용된다.
만약, 고객ID가 숫자형 칼럼이면 , 자동 형변환이 일어나 고객ID가 필터 조건으로 사용된다.

```

4. LIKE를 옵션조건으로 사용할 때는 컬럼 값 길이가 고정적이어야 한다.

```

WHERE 고객명 like :cust_nm || '%'
AND length(고객명) = length(nvl(:cust_nm, 고객명))


WHERE 고객명 like :cust_nm -- 고객명을 입력하지 않을 때 :cust_nm에 '%' 입력

LIKE 옵션 조건에 사용할 때는 칼럼 값 길이가 고정적이어야 한다.
칼럼 값 길이가 가변적일 때는 변수 값 길이가 같은 레코드만 조회되도록 아래와 같이 조건절을 추가해야 한다.

```


#####   UNION ALL 활용


```
SELECT * FROM 거래
WHERE :cust_id IS NULL
AND 거래일자 BETWEEN :dt1 AND :dt2

UNION ALL

SELECT * FROM 거래
WHERE :cust_id IS NOT NULL
AND 고객ID = :cust_id
AND 거래일자 BETWEEN :dt1 AND :dt2


:cust_id 변수에 값을 입력했는지에 따라 위아래 SQL 중 둘 중 하나만 실행되게 하는 방식이다.
:cust_id 변수에 값을 입력하지 않으면, 위쪽 브랜치에서 거래일자가 선두인 인덱스를 사용하고, 
변수에 값을 입력하면 아래쪽 브랜치에서 [고객ID + 거래일자] 인덱스 사용하고 있다.
옵션 조건 컬럼도 인덱스 엑세스 조건으로 사용된다.

단점? SQL 코딩량이 길어진다.

```


##### NVL/DECODE 함수 활용

```
SELECT * FROM 거래
WHERE 고객ID = NVL(:cust_id, 고객ID)
AND 거래일자 BETWEEN :dt1 and :dt2

SELECT * FROM 거래
WHERE 고객ID = DECODE(:cust_id, null, 고객ID, :cust_id)
AND 거래일자 BETWEEN :dt1 and :dt2


NVL, DECODE 둘 중 어느 것을 사용하든 실행계획은 똑같다. 
> cust_id가 입력되지 않으면 거래일자가 선두인 인덱스 사용하고, 변수에 값을 입력하면 아래쪽 브랜치에서 [고객ID + 거래일자] 인덱스 사용한다.
고객ID 칼럼을 함수 인자로 사용(인덱스 칼럼 가공)했는데도, 인덱스를 사용할 수 있는 것은 OR Expansion 쿼리 변환이 일어났기 때문이다. 
> 이 기능이 작동하지 않으면,:cust_id 값을 입력하지 않으면 조건절이 '고객ID=고객ID' 가 돼서  인덱스에서 조건을 만족하는 한 시작점을 찾을 수 없기때문이다.

장점? UNION ALL 보다 단순하고, UNION ALL과 같은 성능을 낸다.
단점? LIKE 패턴과 같이 NULL 허용 컬럼에 사용할 수 없다는 데에 있다. 
조건절 변수에 NULL을 입력하면 NULL 인 레코드가 결과집합에서 누락되기 때문이다. 

옵션 조건 처리용 NVL/DECODE 함수를 여러 개 사용하면 그중 변별력이 가장 좋은 컬럼 기준으로 한 번만 OR Expansion이 일어난다. 
따라서 OR Expansion 기준으로 선택되지 않으면 인덱스 구성 칼럼이어도 모두 필터 조건으로 처리된다.

```


#####  함수호출부하 해소를 위한 인덱스 구성

##### PL/SQL 함수의 성능적 특성

일반적으로 매우 느리다. 성능을 가장 떨어뜨리는 요소는 Recursive Call 이다.

1. 가상머신(VM)상에서 실행되는 인터프리터 언어
2. 호출 시마다 컨텍스트 스위칭 발생
3. 내장 SQL에 대한 Recursive Call발생


---
### 3.4 인덱스 설계

```
인덱스 설계가 어려운 이유

인덱스가 많으면 아래와 같은 문제가 생긴다.

1. DML 성능 저하 (TPS 저하) 
2. 데이터베이스 사이즈 증가 (디스크 공간 낭비) 
3. 데이터베이스 관리 및 운영 비용 증가

인덱스는 정렬 상태도 유지해야해서 수직적 탐색으로 입력 할 블록을 찾는다. 여유 공간이 없다면 인덱스 분할도 발생한다.
핵심 트랜잭션이 참조하는 테이블에 대한 DML 성능 저하는 TPS 저하로 이어지며, 
꼭 필요하지 않은 인덱스로 인해 디스크 공간을 낭비하고 데이터베이스 사이즈가 커지는 만큼 백업, 복제, 재구성 등을 위한 운영 비용도 상승한다.
개별 쿼리 성능뿐만 아니라 인덱스 개수를 최소화함으로써 DML 부하를 줄여야 하므로 인덱스 설계가 어렵다.

```

#####  인덱스 선택에 중요한 기준
일반적인 방식은 Index Range Scan이다.
인덱스 선두 칼럼을 조건절에 반드시 사용해야 한다. 따라서 인덱스를 구성할 때, 
1. 조건절에 항상 사용하거나 자주 사용한느 컬럼을 인덱스로 선정 한다.
2. '=' 조건으로 자주 조회하는 컬럼을 앞 쪽에 둔다.

##### 스캔 효율성 이외의 판단 기준

1. 수행 빈도
2. 업무상 중요도
3. 클러스터링 팩터
4. 데이터양
5. DML 부하
6. 저장 공간
7. 인덱스 관리 비용 등

**수행빈도** 
자주 수행하지 않는 SQL이라면 스캔과정에 있어 비효율이있어도 문제가 되지않지만,
수행 빈도가 매우 높은 SQL에는 앞서 말한 기준을 이용해 최적의 인덱스를 구성해줘야 한다.

**데이터양**
데이터량이 적더라면 FULL Scan으로 충분하기 때문에 인덱스를 만들필요가 없다.
데이터량이 많을 경우 INSERT 도 많기 때문에 초당 DML 발생량은 트랜잭션 성능(TPS)에 직접적인 영향을 준다.

##### 공식을 초월한 전략적 설계

>조건 절 패턴이 열 개 있을 때, 패턴마다 인덱스를 만들 수는 없다.
열 개 중 최적을 달성해야 할 가장 핵심적인 액세스 경로 한두 개를 전략적으로 선택해서 최적 인덱스를 설계하고, 나머지 액세스 경로는 약간의 비효율이 있더라도 목표 성능을 만족하는 수준으로 인덱스를 구성할 수 있어야 한다. 그리고 판단한 기준에 근거가 무언인지 답할 수있어야 한다.

##### 소트 연산을 생략하기 위한 컬럼 추가

인덱스는 항상 정렬 상태를 유지하므로 ORDER BY, GROUP BY를 위한 소트 연산을 생략할 수 있다. 따라서 조건절에 사용하지 않는 칼럼이더라도 소트 연산을 생략할 목적으로 인덱스 구성에 포함시킴으로써 성능 개선을 도모할 수 있다.





```
SELECT 계약ID,입력자ID,보험시작일자,보험종료일자
FROM 계약
WHERE 취급지점ID =:trt_brch_id
AND 청양일자 BETWEEN :sbcp_dt1 AND :sbcp_dt2
AND 입력일자 >= trunc(sysdate-3)
ORDER BY 청약일자, 입력자ID

성능을 고려하지않아도 된다면 [청약일자ID+입력자ID]
취급지점ID '=' 조건을 포함하여 [청약일자ID+취급지점ID+입력자ID] 이렇게 구성 할 수있다.
소트 연산을 생략 할 수 있지만 내부에서는 많은 I/O가 발생한다.


I/O를 최소화하면서 소트 연산을 생략하기 위해서는 아래의 공식에 따라 인덱스를 구성하면 된다. 
1. '=' 연산자로 사용한 조건절 칼럼 선정
2. ORDER BY 절에 기술한 칼럼 추가
3. '=' 연산자가 아닌 조건절 칼럼은 데이터 분포를고려해 추가 여부 결정

공식에 따라 [취급지점ID+청약일자ID+입력자ID] 로 구성한다.


IN 조건은 '=' 조건이 아니다.



인덱스 [거주지역+혈액형+연령]

SELECT 고객번호, 고객명, 거주지역, 혈액형, 연령
FROM 고객
WHERE 거주지역 = '서울'
AND 혈액형 IN ('A','O')
ORDER BY 연령

ORDER BY 절이 있지만, 소트연산을 생략하려면 union all 위쪽 브랜치를 실행하고 이어 아래쪽 브랜치를 실행했을때 그 결과가 연령순으로 정렬되야한다.
가능하려면 서울에 거주하는 모든 A형이 O형보다 어려아한다. 불가능한 일이므로 옵티마이저는 소트연산을 생략하지 않는다.
소트연산을 생략하려면 IN조건이 IN-List Iterator 방식으로 풀려선 안된다, 
즉 IN조건절을 인덱스 액세스 조건으로 사용하면 안된다, 필터조건으로 사용해야한다, 
따라서 인덱스를 [거주지역+연령+혈액형] 순으로 구성해야 한다

```

##### 결합 인덱스 선택도


인덱스 생성 여부를 결정할 때 선택도가 충분히 낮은지 판단하는 것도 중요한 기준이다.
선택도가 높은 인덱스는 테이블 엑세스가 많이 발생해서 효용가치가 없다.
인덱스를 생성할때는 선택도/카디널리티를 확인해야한다.
결합 인덱스 칼럼 간 순서를 정할 때 선택도는 중요할까 
> 아니다.둘 다 인덱스 액세스 조건이므로 어떤 컬럼이 앞으로 오든 인덱스 스캔 범위는 동일하다.
인덱스 생성 여부를 결정할 때는 선택도가 매우 중요하지만, 칼럼 간 순서를 결정할 때는 각 칼럼의 선택보다 
**필수 조건 여부**, **연산자 형태**가 더 중요한 판단기준이 된다.

 [선택도]  전체 레코드 중에서 조건절에 의해 선택되는 레코드의 비율을 말하며, 선택도에 총 레코드 수를 곱한 값은 '카디널리티' 이다. 
따라서 선택도, 카디널리티가 높은 컬럼은 인덱스로 선택해도 효용가치가 없다.

##### 중복 인덱스 제거


* 완전 중복
```
X01 : 계약ID + 청약일자
X02 : 계약ID + 청약일자 + 보험개시일자
X03 : 계약ID + 청약일자 + 보험개시일자 + 보험종료일자

X03 : 계약ID + 청약일자 + 보험개시일자 + 보험종료일자

X03 선두 컬럼이 X01,X02를 포함 하고있기 때문에, X03를 남기고 모두 제거 해도 된다. 


* 불완전 중복
X01 : 계약ID + 청약일자
X02 : 계약ID + 보험개시일자
X03 : 계약ID + 보험종료일자
X04 : 계약ID + 데이터생성일시

X01 : 계약ID + 청약일자 + 보험개시일자 + 보험종료일자 + 데이터생성일시

두번째 컬럼이 모두 다르기때문에 중복이 아니지만, 선두 컬럼의 평균 카디널리티가 매우 낫다면 사실상 중복이다.
계약ID 평균 카디널리티가 5라면,계약ID를 '=' 조건으로 조회하면, 평균 다섯 건이 조회된다는 뜻이다 
그렇다면 이렇게 인덱스를 4개나 만들 이유가 없다.

```
