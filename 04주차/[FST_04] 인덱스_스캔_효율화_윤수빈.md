# 3장. 인덱스 튜닝
## 3.3 인덱스 스캔 효율화
- 운영 환경에서 가능한 일반적인 튜닝 기법은 인덱스 컬럼 추가
- 인덱스 스캔 효율화는 튜닝 요소가 매우 다양함
### 3.3.1 인덱스 탐색
<img width="787" height="352" alt="image" src="https://github.com/user-attachments/assets/48986f6f-e9ca-45ee-aa2b-8651ef4f538e" />

- LMC 레코드 : 키 값을 갖지 않는 특별한 레코드, 자식 노드 중 가장 왼쪽 끝에 위치한 블록을 가리킴
  - <조건절 1>
    <img width="787" height="352" alt="image" src="https://github.com/user-attachments/assets/0033e7ec-2a62-4001-85d5-f5b4b92af443" />
    - 루트 블록 스캔 과정에 C1 = 'B'로 내려가는 것이 아니라 그 직전 레코드가 가리키는 리프 블록 2로 내려가야함
  - <조건절 2>
    <img width="787" height="352" alt="image" src="https://github.com/user-attachments/assets/59af2481-b9a9-4453-bf32-5a440db91cf8" />
    - C1 = 'B' 이고 C2 = '3인 첫 번째 레코드를 찾고, C1 = 'B'인 레코드 중에서 C2 = 4인 레코드를 만나는 순간 스캔을 멈춤
      => C1, C2 모두 스캔량을 줄이는 데 역할을 함
  - <조건절 3>
    <img width="787" height="352" alt="image" src="https://github.com/user-attachments/assets/c24bea57-c2f9-46d4-90ee-36ab751c3b9a" />
    - 수직적 탐색을 통해 C1 = 'B'이고 C2 >= 3인 첫 번째 레코드를 찾고, C1 = 'C'인 레코드를 만날 때까지 스캔하다가 멈춤
      => 부등호 조건이 스캔 시작점을 결정하는 데 중요한 역할을 함
  - <조건절 4>
    <img width="787" height="352" alt="image" src="https://github.com/user-attachments/assets/40ad956c-c8b2-4841-9f10-b7ceb6c2b7a6" />
    - 수직적 탐색을 통해 C1 = 'B' 인 첫 번째 레코드를 찾고, 거기서부터 스캔하다가 C2 > 3 인 첫 번째 레코드를 만나는 순간 스캔을 멈춤
      => 부등호 조건이 스캔을 멈추는 데 중요한 역할을 함
  - <조건절 5>
    <img width="787" height="352" alt="image" src="https://github.com/user-attachments/assets/ddebe6f2-7075-479e-a59f-10863fda3088" />
    => C1, C2 조건절 모두 스캔 시작과 끝 지점을 결정하는 데 중요한 역할을 함
  - <조건절 6>
    <img width="787" height="352" alt="image" src="https://github.com/user-attachments/assets/4cd0dc22-c8b9-4bea-991c-925beaccaa32" />
    => C1 조건절은 스캔 시작과 끝 지점을 결정하는 데 중요한 역할을 했지만, C2는 만 앞 C1 = 'A'인 구간과 C1 = 'C'인 구간에서는 어느 정도 역할을 했으나 C2 = 'B'구간에서는 전혀 역할을 못함
### 3.3.2 인덱스 스캔 효율성
### 3.3.3 액세스 조건과 필터 조건
- 인덱스 액세스 조건 : 인덱스 스캔 범위를 결정하는 조건절
- 인덱스 필터 조건 : 테이블로 액세스할지를 결정하는 조건절
- 테이블 액세스 단계에서 처리되는 조건절은 모두 필터 조건
- 테이블 필터 조건은 쿼리 수행 다음 단계로 전달하거나 최종 결과집합에 포함할지를 결정
### 3.3.4 비교 연산자 종류와 컬럼 순서에 따른 군집성
- 테이블과 달리 인덱스에는 '같은 값'을 갖는 레코드들이 서로 군집해 있음
- 어느 하나를 누락하거나 '=' 조건이 아닌 연산자로 조회하면 조건절을 만족하는 레코드가 서로 흩어진 상태가 됨
  ```
  <조건절 2>
  WHERE C1 = 1
  AND C2 = 'A'
  AND C3 ='나'
  AND C4 >= 'a'
  ```
  - 선행 컬럼은 모두 '='이고 맨 마지막 컬럼만 범위검색 조건일 때 조건을 만족하는 레코드가 서로 모여 있음
  ```
  <조건절 3>
  WHERE C1 = 1
  AND C2 = 'A'
  AND C3 between '가' and '다'
  AND C4 = 'a'
  ```
  - 맨 마지막 컬럼이 아닌 중간 컬럼이 범위검색 조건일 경우
    => 세 번째 컬럼 C3가 범위검색 조건인 경우는 C1 부터 C3까지 세 조건을 만족하는 인덱스 레코드는 서로 모여 있지만 C4 조건까지 만족하는 레코드는 흩어지게 됨
    
  => 선행 컬럼이 모두 '='조건인 상태에서 첫 번째 나타나는 범위검색 조건까지만(이까지에 해당하는 조건이 인덱스 액세스 조건) 만족하는 인덱스 레코드는 모두 연속해서 모여 있지만, 그 이하 조건까지 만족하는 레코드(이후 조건들은 인덱스 필터 조건)는 비교 연산자 종류에 상관없이 흩어짐
### 3.3.5 인덱스 선행 컬럼이 등치(=)조건이 아닐 때 생기는 비효윹
- 인덱스 스캔 효율성은 인덱스 컬럼을 조건절에 모두 등치 조건으로 사용할 때가 가장 좋음
- 인덱스 컬럼 중 일부가 조건절에 없거나 등치 조건이 아니더라도, 그것이 뒤쪽 컬럼일 때는 비효율이 없음
- 인덱스 선행 컬럼이 조건절에 없거나 부등호, BETWEEN, LIKE 같은 범위검색 조건이면, 인덱스를 스캔하는 단계에서 비효율이 생김
### 3.3.6 BETWEEN을 IN-LIST로 전환
- 운영 시스템에서 인덱스 구성을 바꾸기는 쉽지 않음 => BETWEEN 조건을 IN-List로 바꿔주면 큰 효과를 얻는 경우가 있음
  ```
  select 해당층, 평당가, 입력일, 해당동, 매물구분, 연사용일수, 중개업소코드
  from 매물아파트매매
  where 인터넷매물 in ( '1 ' , '2' , '3 ')
  and 아파트시세코드 A01011350900056 '
  and 평형 = '59'
  and 평형타입 = 'A'
  order by 입 력 일 desc
  ```
  <img width="495" height="456" alt="image" src="https://github.com/user-attachments/assets/aa98b4d7-7a55-4c30-9d5d-f25c93750aed" />
  - IN-List 개수만큼 UNION ALL 브랜치가 생성되고 각 브랜치마다 모든 컬럼을 '='조건으로 검색하므로 앞서 선두 컬럼에 BETWEEN을 사용할 때와 같은 비효율이 사라짐
  - IN-List 항목 개수가 늘어날 수 있다면 NL방식의 조인문이나 서브쿼리로 구현 => IN-List 값들을 코드 테이블로 관리하고 있을 때 가능한 방식
- BETWEEN 조건을 IN-List로 전환할 때 주의 사항
  - IN-List 개수가 많지 않아야 함 => 루트에서 브랜치 블록까지 깊이가 깊을때 특히
  - 인덱스 스캔 과정에 선택되는 레코드들이 서로 멀리 떨어져 있을 때만 유용\
### 3.3.7 Index Skip Scan 활용
- BETWEEN 조건을 IN-List로 변환하면 효과적인 상황에서 조건절을 바꾸지 않고도 같은 효과를 내는 방법
- 선두 컬럼이 BETWEEN이어서 나머지 검색 조건을 만족하는 데이터들이 서로 멀리 떨어져 있을 떄, IN-List 보다도 오히려 성능이 나음
### 3.3.8 IN 조건은 '='인가
- IN 조건은 '='이 아님 => 인덱스를 어떻게 구성하느냐에 따라 성능도 달라질 수 있음
- IN 조건이 '='이 되려면 IN-List Iterator 방식으로 풀려야만 함 그렇지 않으면 IN 조건은 필터 조건
- IN 조건을 '='조건 즉 액세스 조건으로 만들기 위해 IN-List Iterator 방식으로 푸는 것이 효과적이려면 데이터가 아주 많아야 함
- NUM_INDEX_KEYS 힌트 활용
  ```
  select /*+ num_index_keys(a 고객별가입상품_X1 1) */ *
  ...
  ```
  - num_index_keys 힌트의 세 번째 인자 '1'인덱스 첫 번째 컬럼까지만 액세스 조건으로 사용하라는 의미
### 3.3.9 BETWEEN 과 LIKE 스캔 범위 비교
- LIKE 보다 BETWEEN을 사용하는 게 나음
  ```
  select * from 테이블
  where 일자 like '2022%'
  and 상품 = B;
  select * from 테이블
  where 일자 between '202201' and '202212'
  and 상품 = B;
  ```
  <img width="724" height="343" alt="image" src="https://github.com/user-attachments/assets/3a9233b5-8060-4075-8bba-bbc05d0b015c" />
  - LIKE의 경우에 '202200'이 저장돼 있다면 그 값도 읽어야 하므로 상품 = B 인 지점으로 바로 내려갈 수 없음
### 3.3.10 범위검색 조건을 남용할 때 생기는 비효율
- 인덱스 구성 컬럼이 있는 조건절을 LIKE로 구사할 때, 액세스 조건이던 컬럼이 필터 조건으로 바뀌면서 인덱스 스캔 범위가 늘어날 수 있음
- 모든 조건절을 BETWEEN으로 처리할 때도 인덱스 스캔 효율을 고려한다면 사용을 자제햐야 함
