# 3장. 인덱스 튜닝
## 3.3 인덱스 스캔 효율화
- 운영 환경에서 가능한 일반적인 튜닝 기법은 인덱스 컬럼 추가
- 인덱스 스캔 효율화는 튜닝 요소가 매우 다양함
### 3.3.1 인덱스 탐색
<img width="787" height="352" alt="image" src="https://github.com/user-attachments/assets/48986f6f-e9ca-45ee-aa2b-8651ef4f538e" />

- LMC 레코드 : 키 값을 갖지 않는 특별한 레코드, 자식 노드 중 가장 왼쪽 끝에 위치한 블록을 가리킴
  - <조건절 1>
    <img width="787" height="352" alt="image" src="https://github.com/user-attachments/assets/0033e7ec-2a62-4001-85d5-f5b4b92af443" />
    - 루트 블록 스캔 과정에 C1 = 'B'로 내려가는 것이 아니라 그 직전 레코드가 가리키는 리프 블록 2로 내려가야함
  - <조건절 2>
    <img width="787" height="352" alt="image" src="https://github.com/user-attachments/assets/59af2481-b9a9-4453-bf32-5a440db91cf8" />
    - C1 = 'B' 이고 C2 = '3인 첫 번째 레코드를 찾고, C1 = 'B'인 레코드 중에서 C2 = 4인 레코드를 만나는 순간 스캔을 멈춤
      => C1, C2 모두 스캔량을 줄이는 데 역할을 함
  - <조건절 3>
    <img width="787" height="352" alt="image" src="https://github.com/user-attachments/assets/c24bea57-c2f9-46d4-90ee-36ab751c3b9a" />
    - 수직적 탐색을 통해 C1 = 'B'이고 C2 >= 3인 첫 번째 레코드를 찾고, C1 = 'C'인 레코드를 만날 때까지 스캔하다가 멈춤
      => 부등호 조건이 스캔 시작점을 결정하는 데 중요한 역할을 함
  - <조건절 4>
    <img width="787" height="352" alt="image" src="https://github.com/user-attachments/assets/40ad956c-c8b2-4841-9f10-b7ceb6c2b7a6" />
    - 수직적 탐색을 통해 C1 = 'B' 인 첫 번째 레코드를 찾고, 거기서부터 스캔하다가 C2 > 3 인 첫 번째 레코드를 만나는 순간 스캔을 멈춤
      => 부등호 조건이 스캔을 멈추는 데 중요한 역할을 함
  - <조건절 5>
    <img width="787" height="352" alt="image" src="https://github.com/user-attachments/assets/ddebe6f2-7075-479e-a59f-10863fda3088" />
    => C1, C2 조건절 모두 스캔 시작과 끝 지점을 결정하는 데 중요한 역할을 함
  - <조건절 6>
    <img width="787" height="352" alt="image" src="https://github.com/user-attachments/assets/4cd0dc22-c8b9-4bea-991c-925beaccaa32" />
    => C1 조건절은 스캔 시작과 끝 지점을 결정하는 데 중요한 역할을 했지만, C2는 만 앞 C1 = 'A'인 구간과 C1 = 'C'인 구간에서는 어느 정도 역할을 했으나 C2 = 'B'구간에서는 전혀 역할을 못함
### 3.3.2 인덱스 스캔 효율성
### 3.3.3 액세스 조건과 필터 조건
- 인덱스 액세스 조건 : 인덱스 스캔 범위를 결정하는 조건절
- 인덱스 필터 조건 : 테이블로 액세스할지를 결정하는 조건절
- 테이블 액세스 단계에서 처리되는 조건절은 모두 필터 조건
- 테이블 필터 조건은 쿼리 수행 다음 단계로 전달하거나 최종 결과집합에 포함할지를 결정
### 3.3.4 비교 연산자 종류와 컬럼 순서에 따른 군집성
- 테이블과 달리 인덱스에는 '같은 값'을 갖는 레코드들이 서로 군집해 있음
- 어느 하나를 누락하거나 '=' 조건이 아닌 연산자로 조회하면 조건절을 만족하는 레코드가 서로 흩어진 상태가 됨
  ```
  <조건절 2>
  WHERE C1 = 1
  AND C2 = 'A'
  AND C3 ='나'
  AND C4 >= 'a'
  ```
  - 선행 컬럼은 모두 '='이고 맨 마지막 컬럼만 범위검색 조건일 때 조건을 만족하는 레코드가 서로 모여 있음
  ```
  <조건절 3>
  WHERE C1 = 1
  AND C2 = 'A'
  AND C3 between '가' and '다'
  AND C4 = 'a'
  ```
  - 맨 마지막 컬럼이 아닌 중간 컬럼이 범위검색 조건일 경우
    => 세 번째 컬럼 C3가 범위검색 조건인 경우는 C1 부터 C3까지 세 조건을 만족하는 인덱스 레코드는 서로 모여 있지만 C4 조건까지 만족하는 레코드는 흩어지게 됨
    
  => 선행 컬럼이 모두 '='조건인 상태에서 첫 번째 나타나는 범위검색 조건까지만(이까지에 해당하는 조건이 인덱스 액세스 조건) 만족하는 인덱스 레코드는 모두 연속해서 모여 있지만, 그 이하 조건까지 만족하는 레코드(이후 조건들은 인덱스 필터 조건)는 비교 연산자 종류에 상관없이 흩어짐
### 3.3.5 인덱스 선행 컬럼이 등치(=)조건이 아닐 때 생기는 비효윹
- 인덱스 스캔 효율성은 인덱스 컬럼을 조건절에 모두 등치 조건으로 사용할 때가 가장 좋음
- 인덱스 컬럼 중 일부가 조건절에 없거나 등치 조건이 아니더라도, 그것이 뒤쪽 컬럼일 때는 비효율이 없음
- 인덱스 선행 컬럼이 조건절에 없거나 부등호, BETWEEN, LIKE 같은 범위검색 조건이면, 인덱스를 스캔하는 단계에서 비효율이 생김
    
