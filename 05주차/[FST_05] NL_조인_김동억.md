# 4장. 조인 튜닝

## 4.1 NL 조인

### 4.1.1 기본 메커니즘

- NL 조인(Nested Loop Join)은 **중첩 루프(Nested Loop) 방식**을 사용하며, 중첩 루프문과 같은 수행 구조를 가짐

  - **인덱스 사용:** 일반적으로 **Outer**와 **Inner** 양쪽 테이블 모두의 인덱스 사용
    - Outer 테이블은 크기가 작을 경우 Full Scan을 할 수도 있지만, Inner 테이블은 인덱스를 사용해야 효율적

### 4.1.2 NL 조인 실행계획 제어

- NL 조인 실행계획은 Outer 테이블을 기준으로 Inner 테이블과 조인하는 형태로 나타남

  - **제어 힌트:** `use_nl` 힌트를 사용합니다.
  - **힌트 사용 예시:**
    ```sql
    /*+ ordered use_nl(B) use_nl(c) use_hash(d) */
    ```
    > 이는 A $\to$ B $\to$ C 순서로 **NL 조인**하고, D는 **해시 조인**하라는 의미

### 4.1.3 NL 조인 수행 과정 분석

- NL 조인은 각 단계를 모두 완료하고 다음 단계로 넘어가는 것이 아니라, **한 레코드씩 순차적으로 진행**

- **예시 쿼리:**

```sql
select /*+ ordered use_nl(c) index(e) index(c) */
e.사원번호, e.사원명, e.입사일자, c.고객번호, c.고객명, c.전화번호, c.최종주문금액
from 사원 e, 고객 c
where c.고객사원번호 = e.사원번호
and e.입사일자 >= '19960101'
and e.부서코드 = 'z123'
and c.최종주문금액 >= 20000
```

- **수행 과정:**

  1.  **사원\_X1 인덱스 Range Scan** (실행계획 3): `e.입사일자 >= '19960101'` 조건을 만족하는 레코드를 찾음
  2.  **사원 테이블 액세스** (실행계획 2): 인덱스를 통해 테이블에 접근하여 `e.부서코드 = 'z123'` 필터 조건확인
  3.  **고객\_X1 인덱스 Range Scan** (실행계획 5): 사원 테이블에서 읽은 사원번호 값으로 조인 조건(`c.고객사원번호 = e.사원번호`)을 만족하는 고객 레코드를 찾기 위해 인덱스탐색
  4.  **고객 테이블 액세스** (실행계획 4): 고객\_X1 인덱스에서 읽은 ROWID로 고객 테이블에 접근하여 `c.최종주문금액 >= 20000`을 필터링


### 4.1.4 NL 조인 튜닝 포인트

- NL 조인의 성능을 개선하기 위한 핵심 요소들

  1.  **선행 테이블의 인덱스:** 사원\_X1 인덱스만 읽고 테이블 액세스하는 과정의 비효율이 크다면, **인덱스에 `부서코드`와 같은 필터 조건을 추가**하여 인덱스 단계에서 필터링이 되도록 함
  2.  **선행 테이블의 필터링 결과 건수:** **조인 액세스 횟수**는 Outer 테이블의 필터링 결과 건수에 의해 결정되므로, 이 횟수가 많을수록 성능 저하
  3.  **후행 테이블의 테이블 액세스:** 후행 테이블의 조건이 필터링 되는 부분에서 테이블 액세스가 많다면, **인덱스에 필터 조건 컬럼을 추가**하는 것을 고려
  4.  **선행 테이블의 크기가 전체 일량을 좌우:** 선행 테이블(혹은 선행 테이블의 첫 인덱스 스캔 결과)이 전체 작업량 결정



### 4.1.5 NL 조인 특징 요약

| 특징 | 내용 |
| :--- | :--- |
| **액세스 방식** | **랜덤 액세스** 위주의 조인 방식입니다. |
| **진행 방식** | **한 레코드씩 순차적**으로 진행하며, **부분범위 처리**가 가능할 때 좋습니다. |
| **핵심 전략** | **인덱스 구성 전략**이 매우 중요합니다. |
| **적합 환경** | **소량 데이터** 처리나 **부분범위 처리**가 필요한 **OLTP 환경**에 적합합니다. |

-----

### 4.1.6 NL 조인 튜닝 실습

**예시 쿼리:**

```sql
select /*+ ordered use_nl(c) index(e) index(c) */
e.사원번호, e.사원명, e.입사일자, c.고객번호, c.고객명, c.전화번호, c.최종주문금액
from 사원 e, 고객 c
where c.고객사원번호 = e.사원번호
and e.입사일자 >= '19960101'
and e.부서코드 = 'z123'
and c.최종주문금액 >= 20000
```

1.  **불필요한 테이블 액세스 제거 (인덱스 수정)**

      * **문제:** 인덱스 스캔 결과(`Rows`)가 2780건인데, 테이블에서 필터링한 결과는 3건이라면, **불필요한 테이블 액세스 과정**이 많았음을 의미
      * **해결:** **인덱스에 필터 조건 컬럼을 추가**하여 테이블 액세스 후 필터링 비율 줄임

2.  **인덱스 컬럼 순서 변경 (Range Scan 비효율 해결)**

      * **문제:** 기존 인덱스 [입사일자 + 부서코드]에서 `입사일자`가 `BETWEEN` 조건이라 인덱스에서 3건을 얻기 위해 50,000여개 레코드(논리적 블록 요청 횟수(`cr`)로 확인)를 읽는 **인덱스 스캔 단계의 일량** 비효율 발생
      * **해결:** 인덱스 순서를 **[부서코드 + 입사일자]**로 변경하여 두 조건 모두 인덱스 액세스 조건이 되도록 함

3.  **조인 순서 변경 검토**

      * **문제:** 사원 테이블을 읽는 비효율은 사라졌으나, **고객과의 조인 과정에서 비효율**이 발생했습니다. 조인은 2780번 시도하지만 최종 결과집합은 5건뿐
      * **해결:** **조인 순서 변경**을 고려
      * **대안:** 조인 순서를 바꿔도 소득이 없다면 **소트 머지 조인**이나 **해시 조인**을 검토


### 4.1.7 NL 조인 확장 메커니즘

- NL 조인 성능을 높이기 위해 도입된 **기능**

  - **테이블 Prefetch:** 인덱스를 이용해 테이블을 액세스할 때 디스크 I/O가 필요하면, 곧 읽게 될 블록까지 **미리 읽어서 버퍼캐시에 적재**하는 **기능**
  - **배치 I/O (Batch I/O):** 디스크 I/O Call을 미뤘다가, 읽을 블록이 일정량 쌓이면 **한꺼번에 처리**하는 **기능**
  - Inner쪽 테이블에 대한 디스크 I/O 과정에서 작동할 수 있음

## 4.2 소트 머지 조인

### 4.2.1 SGA vs. PGA

| 구분      | 설명                                   |
| ------- | ------------------------------------ |
| **SGA** | 여러 프로세스가 **공유하는 메모리 공간**, 래치 메커니즘 필요 |
| **PGA** | 프로세스별 **개별 메모리 공간**, 래치 불필요          |

### 4.2.2 기본 메커니즘

* 두 단계로 구성:

  1. **소트 단계:**

     * 양쪽 집합에서 조건에 맞는 데이터를 읽고 **조인 컬럼 기준으로 정렬**
     * 결과는 **PGA**에 저장 (부족 시 Temp 공간 사용)
  2. **머지 단계:**

     * 정렬된 양쪽 집합을 **Loop**로 병합
     * NL 조인과 유사하지만, **Full Scan 반복 없음**

### 4.2.3 소트 머지 조인이 빠른 이유

* **OLAP 환경(대량 데이터)**에서 유리한 이유:

  * NL 조인은 인덱스 접근 시 **버퍼 캐시 경유**로 오버헤드 발생
  * 소트 머지 조인은 **PGA 내에서 일괄 조인 수행**
  * 버퍼 캐시 경합이 없어 효율적
* 단, 초기 소트 시에는 버퍼 캐시를 거쳐 **Table Full Scan 또는 인덱스 스캔** 수행.

### 4.2.4 소트 머지 조인의 주용도

* **해시 조인 등장 이후 사용 빈도 감소**, 그러나 아래 상황에서는 여전히 유효:

  * **등치(=) 조건이 아닌** 대량 데이터 조인
  * **조인 조건이 없는 Cross Join**

### 4.2.5 소트 머지 조인 제어하기

* 힌트: `use_merge(_)`
  → 실행계획에서 소트 머지 조인을 강제로 유도할 수 있음

### 4.2.6 소트 머지 조인 특징 요약

* 실시간으로 **조인을 위한 인덱스를 생성하는 것과 유사**
* **인덱스 유무에 영향받지 않음**
* **스캔 위주의 접근 방식**으로 대량 데이터에 적합