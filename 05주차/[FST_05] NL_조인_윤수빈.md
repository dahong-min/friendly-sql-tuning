# 4장. 조인 튜닝
## 4.1 NL 조인
- NL 조인(Nested Loop 조인) : 중첩 반복문 조인
- 소트 머지 조인, 해시 조인과 프로세싱 과정은 동일
### 4.1.1 기본 메커니즘
ex) 1996년 1월 1일 이후 입사한 사원이 관리하는 고객 데이터를 추출하는 프로그램 
  
  - NL 조인 알고리즘 : 사원 테이블로부터 1996년 1월 1일 이후 입사한 사원일 찾아 '건건이' 고객 테이블에서 사원번호가 일차하는 레코드를 찾는 것 (중첩 루프문과 같은 수행 구조)
  - NL 조인은 Outer 쪽 테이블은 인덱스를 이용하지 않더라도 Inner 쪽 테이블은 인덱스를 써야함
    => Inner 쪽 테이블 인덱스를 이용하지 않을 경우, Outer 루프에서 읽은 건수만큼 Table Full Scan을 반복하기 때문
  - 인덱스를 이용해 NL 조인하는 과정
    <img width="3533" height="1528" alt="image" src="https://github.com/user-attachments/assets/4fa4d57a-8102-4dc8-b756-8db6f3383d46" />
    - 외부 테이블에서 한 행을 읽고 내부 테이블에서 조인 조건에 맞는 행을 찾음 -> 외부 테이블의 모든 행에 대해 반복  
      => 행이 많아질수록 느려질 수 있음
    <img width="3439" height="1534" alt="image" src="https://github.com/user-attachments/assets/e7449ff4-84fc-4ea7-8348-b46596334a2a" />
    - 내부 테이블에 조인 컬럼에 인덱스가 있을 경우, 내부 테이블 전체 스캔없이 인덱스로 빠르게 찾음  
      => Inner 쪽 테이블 인덱스로 최적화된 NL 조인

    => 결과적으로 모든 외부 행에 대해 내부 인덱스 접근을 반복하는 형태이므로 내부 테이블의 인덱스 존재 여부가 성능을 결정
### 4.1.2 NL 조인 실행계획 제어
- 힌트 설명
  - ordered : FROM 절에 기술한 순서대로 조인하라
  - use_nl : NL 방식으로 조인하라
```
select /*+ ordered use_nl(c) */
      e.사원명, c.고객명, c.전화번호
from 사원 e, 고객 c
where e.입사일자 >= '19960101'
and c.관리사원번호, e.사원번호
```
=> 사원 테이블 기준으로 고객 테이블과 NL 방식으로 조인하라

```
select /*+ ordered use_nl(B) use_nl(C) use_hash(D) */ *
from A, B, C, D
where ...
```
=> A -> B -> C -> D 순으로 조인하되, B, C 와 조인할 때는 NL 방식, D와 조인할 때는 해시 방식으로 조인하라

```
select /*+ leading(C, A, D, B) use_nl(A) use_nl(D) use_hash(B) */ *
from A, B, C, D
where ...
```
=> C -> A -> D -> B 순으로 조인하되, A, D 와 조인할 때는 NL 방식, B와 조인할 때는 해시 방식으로 조인하라

```
select /*+ use_nl(A, B, C, D) */ *
from A, B, C, D
where ...
```
=> 네 개 테이블을 NL 방식으로 조인하되, 조인 순서는 옵티마이저에게 맡김

### 4.1.3 NL 조인 수행 과정 분석
```
SELECT /*+ ordered use_nl(c) index(e) index(c) */
    e.사원번호, e.사원명, e.입사일자,
    c.고객번호, c.고객명, c.전화번호, c.최종주문금액
FROM 사원 e, 고객 c
WHERE c.관리사원번호 = e.사원번호  ①
AND e.입사일자 >= '19960101'  ②
AND e.부서코드 = 'Z123'  ③
AND c.최종주문금액 >= 20000  ④
```
- 조건절 비교 순서 : ② -> ③ -> ① -> ④
<img width="570" height="313" alt="image" src="https://github.com/user-attachments/assets/8e98b7c0-5c2b-44d4-8336-f0065f9d26a7" />

=> 각 단계를 모두 완료하고 다음 단계로 넘어가는 게 아니라 한 레코드씩 순차적으로 진행
### 4.1.4 NL 조인 튜닝 포인트
- 외부/내부 테이블 조건에 의해 필터링되는 비율이 높다면 해당 컬럼을 인덱스로 추가하는 방안 고려해야함
- 조인 액세스 횟수가 많을수록 성능이 느려짐
- 외부 테이블 인덱스에서 얻은 결과 건수에 의해 전체 일량 좌우

- 올바른 조인 메소드 선택
  - OLTP 시스템에서 튜닝할 때는 일차적으로 NL 조인부터 고려하고 이후에 소트 머지 조인 or 해시 조인 검토
### 4.1.5 NL 조인 특징 요약
- 랜덤 액세스 위주의 조인 방식
- 한 레코드씩 순차적으로 진행
- 인덱스 구성 전략이 특히 중요

=> 즉, NL 조인은 소량 데이터를 주로 처리하거나 부분범위 처리가 가능한 OLTP 시스템에 적합한 조인 방식
### 4.1.6 NL 조인 튜닝 실습
<img width="1679" height="705" alt="image" src="https://github.com/user-attachments/assets/0d6e91b9-9e1e-425d-8ad4-828013ab7985" />

- 테이블 액세스 후 필터링되는 비율이 높다면 인덱스에 테이블 필터 조건 컬럼을 추가하는 것을 고려할 필요가 있음
<img width="1872" height="806" alt="image" src="https://github.com/user-attachments/assets/167abe60-8115-43ae-9109-593051cf5e82" />

- 테이블 액세스하기 전 인덱스 스캔 단계에서의 일량 또한 확인해야 함
<img width="2821" height="722" alt="image" src="https://github.com/user-attachments/assets/8576ba1e-c654-4967-bf68-05fb37d1bcee" />

- 오라클 9iR2부터 각 처리 단계별 논리적인 블록 요청 횟수(cr), 디스크에서 읽은 블록 수(pr), 디스크에 쓴 블록 수(pw) 표시
  
- 튜닝 방법 : 사원_X1 인덱스 컬럼 순서 조정 [부서코드 + 입사일자] 순으로 구성 but 다른 쿼리에 미치는 영향도 분석이 선행되어야 함
<img width="2509" height="728" alt="image" src="https://github.com/user-attachments/assets/899001b3-20f9-4582-9fe7-bc2dabad7191" />

- 2780 번의 조인 시도를 했음에 비해 최종 결과집합은 다섯 건뿐 => 최종주문금액 조건절에 부합하는 레코드가 별로 없을 시 조인 순서 변경 고려해야 함
### 4.1.7 NL 조인 확장 메커니즘
- 테이블 Prefetch : 인덱스를 이용해 테이블을 액세스하다가 디스크 I/O가 필요해지면, 이어서 곧 읽게 될 블록까지 미리 읽어서 버퍼캐시에 적재하는 기능
  -> 실행계획  
   
  <img width="1331" height="583" alt="image" src="https://github.com/user-attachments/assets/54de965f-c639-421a-a2dd-4e07b23800f3" />

- 배치 I/O : 디스크 I/O Call을 미뤘다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리하는 기능
  -> 실행계획
  
  <img width="1451" height="732" alt="image" src="https://github.com/user-attachments/assets/9823e4c7-9ec8-4d60-a099-5f8181a8b2d6" />

=> 읽는 블록마다 건건이 I/O Call을 발생시키는 비효율을 줄이기 위해 고안
## 4.2 소트 머지 조인
### 4.2.1 SGA vs. PGA
<img width="1438" height="1130" alt="image" src="https://github.com/user-attachments/assets/1d19a220-7438-466a-abab-d2ad8dbfb041" />  

- 오라클 서버 프로세스는 SGA에 공유된 데이터를 읽고 쓰면서, 동시에 자신만의 고유한 메모리 영역인 PGA를 가짐  
- 할당받은 PGA 공간에 데이터를 모두 저장할 수 없을 때는 Temp 테이블스페이스를 이용  
- PGA는 래치 메커니즘이 불필요 -> SGA 버퍼캐시에서 읽을 때보다 훨씬 빠름  
### 4.2.2 기본 메커니즘
- 소트 단계 : 양쪽 집합을 조인 컬럼 기준으로 정렬
- 머지 단계 : 정렬한 양쪽 집합을 서로 머지함

```
SELECT /*+ ordered use_merge(c) */
    e.사원번호, e.사원명, e.입사일자,
    c.고객번호, c.고객명, c.전화번호, c.최종주문금액
FROM 사원 e, 고객 c
WHERE c.관리사원번호 = e.사원번호
AND e.입사일자 >= '19960101'
AND e.부서코드 = 'Z123'
AND c.최종주문금액 >= 20000
```

  1. 조건에 해당하는 사원 and 고객 데이터를 읽어 조인컬럼인 사원번호 and 관리사원번호 순으로 정렬하여 PGA 영역에 저장, 데이터 모두 저장할 수 없으면 Temp 테이블스페이스에 저장  
  2. PGA에 저장한 사원 데이터를 스캔하면서 PGA에 저장한 고객 데이터와 조인  
=> 사원 데이터를 기준으로 고객 데이터를 매번 Full Scan 하지 않음  
=> 조인 컬럼에 인덱스가 없어도 사용할 수 있는 조인 방식
4.2.3 소트 머지 조인이 빠른 이유
- NL 조인 : 조인 과정에서 액세스하는 모든 블록을 랜덤 액세스 방식으로 '건건이' DB 버퍼캐시를 경유함 => 읽는 모든 블록에 래치 획득, 캐시버퍼 체인 스캔 과정을 거침
- 소트 머지 조인 : 조인 대상 집합을 '일괄적으로' 읽어 PGA에 저장 후 조인하여 래치 획득 과정이 없음
=> 대량 데이터 조인에 유리한 이유
4.2.4 소트 머지 조인의 주용도
- 조인 조건식이 등치(=) 조건이 아닌 대량 데이터 조인
- 조인 조건식이 아예 없는 조인
4.2.5 소트 머지 조인 제어하기
* 위 코드 참고
  - 양쪽 테이블을 조인 컬럼 순으로 각각 정렬한 후 '정렬된 사원' 기준으로 '정렬된 고객'과 조인하라
4.2.6 소트 머지 조인 특징 요약
- 소트 부하만 감수한다면, 건건이 버퍼캐시를 경유하는 NL 조인보다 빠름
- 조인 컬럼에 인덱스가 없는 상황에서 두 테이블을 각각 읽어 조인 대상 집합을 줄잉ㄹ 수 있을 때 아주 유리함
- 스캔 위주의 액세스 방식을 사용
