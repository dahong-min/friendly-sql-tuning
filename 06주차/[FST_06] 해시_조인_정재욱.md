# 해시 조인

## 기본 메커니즘

해시 조인은 Build와 Probe 두 단계로 나뉘어 진행된다.

**Build 단계**

- 작은 쪽 테이블(Build Input)을 읽어 해시 테이블(해시 맵)을 생성
- 조인 컬럼을 해시 함수에 입력하여 해시 키를 생성하고, 해당 해시 체인에 데이터를 연결
- 해시 테이블은 PGA 영역의 Hash Area에 저장
- 용량이 부족하면 Temp 테이블스페이스(디스크)에 저장

**Probe 단계**

- 큰 쪽 테이블(Probe Input)을 읽어 해시 테이블을 탐색하면서 조인
- 조인 컬럼을 해시 함수에 입력하여 해시 체인을 찾고 매칭되는 데이터를 조인
- NL 조인과 처리 방식이 유사

**힌트 사용**

- `use_hash`: 해시 조인 유도
- `leading` 또는 `ordered`: Build Input 테이블 지정
- `swap_join_inputs`: 특정 테이블을 Build Input으로 명시
- `no_swap_join_inputs`: Probe Input을 명시

## 해시 조인이 빠른 이유

**PGA 영역 활용**

- 해시 테이블이 PGA의 Hash Area에 할당되어 래치 획득 과정 없이 데이터 탐색 및 조인 가능
- NL 조인처럼 랜덤 액세스 부하도 없음

**소트 머지 조인과의 비교**

- 소트 머지 조인: 양쪽 테이블을 모두 정렬해야 하므로 PGA 부족 시 Temp 테이블스페이스 사용 빈번
- 해시 조인: 한쪽(보통 작은 쪽)만 해시 맵으로 만들면 되므로 디스크 작업이 적음
- 대량 데이터 조인 시 일반적으로 해시 조인이 가장 빠름

**주의사항**

- Build Input과 Probe Input을 읽을 때는 DB 버퍼 캐시를 경유하며 인덱스를 사용할 수도 있음
- 이 과정에서 발생하는 버퍼 캐시 탐색 비용과 랜덤 액세스 부하는 불가피

## 대용량 Build Input 처리

두 테이블 모두 대용량이어서 인메모리 해시 조인이 불가능한 경우, 분할 정복(Divide and Conquer) 방식으로 처리한다.

**파티션 단계**

- 양쪽 집합의 조인 컬럼에 해시 함수를 적용
- 반환된 해시 값에 따라 동적으로 파티셔닝
- 파티션된 데이터를 Temp 테이블스페이스(디스크)에 저장
- 인메모리 해시 조인보다 성능이 떨어짐

**조인 단계**

- 각 파티션 쌍(pair)에 대해 독립적으로 조인 수행
- 파티션별로 작은 쪽을 Build Input으로 선택하여 해시 테이블 생성
- 반대쪽 파티션을 읽으면서 해시 테이블 탐색 및 조인
- 모든 파티션 쌍 처리 완료까지 반복

## 해시 조인 실행계획 제어

**실행계획 해석**

- 위쪽(HASH JOIN 바로 아래)이 Build Input으로 해시 테이블 생성
- 아래쪽이 Probe Input으로 해시 테이블 탐색
- 각 테이블 읽을 때 인덱스 사용 여부는 실행계획에서 확인 가능

**Build Input 선택**

- `use_hash` 힌트만 사용 시: 옵티마이저가 카디널리티 작은 테이블 자동 선택
- 직접 선택: `leading` 또는 `ordered` 힌트 사용
- `leading` 힌트의 첫 번째 파라미터 테이블은 무조건 Build Input으로 선택됨

**세 개 이상 테이블 조인**

- A, B, C 조인 시 A↔B↔C 방식으로 진행
- `swap_join_inputs`: Build Input 변경
- `no_swap_join_inputs`: 조인 결과집합을 Build Input으로 사용

## 조인 메소드 선택 기준

**일반적인 선택 기준**

- 소량 데이터 조인 → NL 조인
- 대량 데이터 조인 → 해시 조인
- 등치(=) 조건이 아닌 조인 또는 카테시안 곱 → 소트 머지 조인

**수행 빈도가 높은 쿼리**

- NL 조인과 해시 조인 성능이 비슷하거나 해시 조인이 약간 빠른 경우 → NL 조인 선택
- 해시 조인이 매우 빠른 경우에만 → 해시 조인 선택

**이유**

- 인덱스(NL 조인): 영구적으로 유지되며 다양한 쿼리에서 공유 및 재사용 가능
- 해시 테이블: 단일 쿼리를 위해 생성되고 조인 종료 후 즉시 소멸
- 해시 조인은 CPU와 메모리 사용률이 높고 해시 맵 생성 과정에서 래치 경합 발생 가능

**해시 조인 권장 조건**

1. 수행 빈도가 낮고
2. 쿼리 수행 시간이 오래 걸리며
3. 대량 데이터를 조인할 때

※ 옵티마이저는 수행 빈도를 고려하지 않으므로 개발자가 판단해야 함

---

# 서브쿼리 조인

## 서브쿼리 변환이 필요한 이유

**서브쿼리 종류**

- 스칼라 서브쿼리(Scalar Subquery): SELECT 절에 사용, 한 레코드당 정확히 하나의 값 반환
- 인라인 뷰(Inline View): FROM 절에 사용
- 중첩된 서브쿼리(Nested Subquery): WHERE 절에 사용, 결과집합 한정

**변환 필요성**

- 옵티마이저는 쿼리 블록 단위로 최적화 수행
- 메인 쿼리와 서브쿼리를 각각 최적화하면 전체적으로 최적화되지 않을 수 있음
- 전체 쿼리 최적화를 위해 서브쿼리 변환이 필요

## 서브쿼리와 조인

### 필터 오퍼레이션

**기본 특징**

- 중첩된 서브쿼리를 필터처럼 사용하는 방식
- NL 조인과 로직이 유사하지만 몇 가지 차이점 존재

**NL 조인과의 차이점**

1. 조건을 만족하는 레코드를 만나면 즉시 inner loop 종료(break)
2. 캐싱 기능: 서브쿼리 입력값과 반환값을 PGA에 캐싱하여 재수행 방지
3. 조인 순서: 항상 메인쿼리가 Outer, 서브쿼리가 Inner로 고정

### 서브쿼리 Unnesting

**개념**

- 메인과 서브쿼리 간 계층구조를 없애고 같은 레벨로 변환
- 다양한 조인 방식(NL 조인, 해시 조인, 소트 머지 조인 등) 적용 가능

**장점**

1. 세미 조인(`nl_sj`) 등 다양한 조인 방식 선택 가능
2. 서브쿼리를 메인쿼리보다 먼저 처리 가능
3. 전체적으로 더 나은 실행 경로 탐색 가능

**힌트**

- `unnest`: Unnesting 유도
- `no_unnest`: 필터 오퍼레이션 유도

**주의사항**

- 서브쿼리에 ROWNUM 사용 시 Unnesting이 차단됨
- ROWNUM은 "해당 서브쿼리를 건드리지 말라"는 의미와 유사

### 서브쿼리 Pushing

**개념**

- 서브쿼리 필터링을 가능한 한 앞 단계에서 처리
- 조인 단계로 넘어가는 로우 수를 사전에 줄임

**사용 조건**

- Unnesting되지 않은 서브쿼리에만 작동
- `no_unnest`와 `push_subq` 힌트를 함께 사용
- 나중에 처리하려면 `no_unnest`와 `no_push_subq`를 함께 사용

## 뷰(View)와 조인

### Merge

**개념**

- 인라인 뷰를 메인쿼리와 머징하여 하나의 쿼리로 변환
- 뷰를 독립적으로 최적화하지 않고 전체를 함께 최적화

**장점**

- 인덱스 사용 가능

**단점**

- 전체 데이터 병합 후 GROUP BY 등 연산 수행
- 부분 범위 처리 불가능

### 조인 조건 Pushdown

**개념**

- 메인쿼리를 실행하면서 조인 조건절 값을 건건이 뷰 안으로 밀어넣는 방식
- `no_merge`와 `push_pred` 힌트를 함께 사용

**장점**

- 조인 조건을 인라인 뷰 안에서 먼저 처리 가능
- 건건이 처리하므로 부분 범위 처리 가능
- Merge나 독립 최적화 방식에서는 불가능한 최적화

**기타 방식**

- Lateral 인라인 뷰, Cross/Outer Apply 조인
- 인라인 뷰에 조인 조건절 값을 직접 삽입 가능
- 주로 복잡한 쿼리에서 Pushdown이 작동하지 않을 때 사용

## 스칼라 서브쿼리 조인

**기본 특징**

- SELECT 절에서 사용하는 서브쿼리
- 함수와 달리 컨텍스트 스위칭 없이 메인쿼리와 한번에 실행
- NL 조인 방식으로 실행되지만 캐싱 기능 보유

**캐싱 메커니즘**

- 입력값에 대한 반환값을 PGA 메모리에 캐싱
- 쿼리 시작 시 할당, 종료 시 반환
- 매번 서브쿼리를 재수행하지 않고 캐시에서 결과값 조회

**캐싱 효과적인 경우**

- 입력값 종류가 적어 해시 충돌 가능성이 낮을 때
- 메인 쿼리 건수가 충분히 많을 때

**캐싱 부작용**

- 캐시 용량이 제한적이고 입력값 경우의 수가 많으면 효과 감소
- 매번 캐시 확인 비용이 오히려 성능 저하 유발
- CPU와 메모리 사용률만 증가

**제약사항**

- 두 개 이상의 값 반환 불가
- 여러 값이 필요한 경우 인라인 뷰로 변환하거나 문자열 결합, TYPE 활용

**대용량 처리**

- NL 조인 방식이므로 캐싱 효과가 크지 않으면 랜덤 I/O 부담 발생
- 대용량 병렬 쿼리에서는 스칼라 서브쿼리 사용 지양

**스칼라 서브쿼리 Unnesting**

- 오라클 12c부터 옵티마이저가 자동으로 쿼리 변환
- 다양한 조인 방식 선택 가능
- 문제 발생 시 `_optimizer_unnest_scalar_sq` 파라미터를 false로 설정하여 기능 비활성화 가능
